<!doctype html>
<html class="no-js" lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        烂笔头
    </title>
    <meta name="description" content="">
    <link href="atom.xml" rel="alternate" title="烂笔头" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>
        hljs.initHighlightingOnLoad();
    </script>

</head>

<body class="antialiased hide-extras"></body>

<div class="inner-wrap">


    <nav class="top-bar docs-bar hide-for-small" data-topbar>

        <div id="header">
            <h1><a href="index.html">烂笔头</a></h1>
        </div>

    </nav>


    <div class="row">
        <div class="sidebar">
            <ul id="side-nav" class="side-nav">

                
                <li class="side-title"><span>Android</span></li>
                
                <li><a title="移除第三方SDK所声明的权限" href="16280619241100.html">移除第三方SDK所声明的权限</a></li>
                
                <li><a title="Android登录页面，未勾选用户协议、隐私政策出现抖动效果" href="16280609822586.html">Android登录页面，未勾选用户协议、隐私政策出现抖动效果</a></li>
                
                <li><a title="DialogFragment内存泄露问题能不能一次性改好" href="16251021954820.html">DialogFragment内存泄露问题能不能一次性改好</a></li>
                
                <li><a title="Android静默安装实现方案，仿360手机助手秒装和智能安装功能" href="16251021954779.html">Android静默安装实现方案，仿360手机助手秒装和智能安装功能</a></li>
                
                <li><a title="Android 添加水印功能" href="16251021954737.html">Android 添加水印功能</a></li>
                
                <li><a title="Android 监听手电筒状态" href="16251021954689.html">Android 监听手电筒状态</a></li>
                 
                <li class="side-title"><span>Github</span></li>
                
                <li><a title="使用Github+jsdelivr构建你的免费图床" href="16251022060206.html">使用Github+jsdelivr构建你的免费图床</a></li>
                 
                <li class="side-title"><span>Glide</span></li>
                
                <li><a title="Glide源码修改-自定义磁盘缓存实现永久存储" href="16251022251608.html">Glide源码修改-自定义磁盘缓存实现永久存储</a></li>
                
                <li><a title="Android—Glide使用教程（一）" href="16251022251568.html">Android—Glide使用教程（一）</a></li>
                
                <li><a title="Android—Glide使用教程（二）" href="16251022251484.html">Android—Glide使用教程（二）</a></li>
                
                <li><a title="Android—Glide使用教程（三）" href="16251022251527.html">Android—Glide使用教程（三）</a></li>
                 
                <li class="side-title"><span>Gradle</span></li>
                
                <li><a title="Gradle 自定义Plugin插件之上传APK到蒲公英" href="16280610391708.html">Gradle 自定义Plugin插件之上传APK到蒲公英</a></li>
                
                <li><a title="自定义Gradle Plugin，优雅的解决第三方Jar包中的bug" href="16280610391664.html">自定义Gradle Plugin，优雅的解决第三方Jar包中的bug</a></li>
                
                <li><a title="如何使用Android Studio开发Gradle插件" href="16280610391616.html">如何使用Android Studio开发Gradle插件</a></li>
                
                <li><a title="sourceSets使用" href="16251022385733.html">sourceSets使用</a></li>
                
                <li><a title="脑洞大开，Gradle项目管理依赖的船新版本" href="16251022385689.html">脑洞大开，Gradle项目管理依赖的船新版本</a></li>
                 
                <li class="side-title"><span>Rxjava</span></li>
                
                <li><a title="RxJava2 只看这一篇文章就够了" href="16251022491138.html">RxJava2 只看这一篇文章就够了</a></li>
                 
                <li class="side-title"><span>GreenDAO</span></li>
                
                <li><a title="GreenDao 3.3.0 基本使用与入门 （一）" href="16280610693006.html">GreenDao 3.3.0 基本使用与入门 （一）</a></li>
                
                <li><a title="GreenDao 3.3.0 多表关联使用（二）" href="16280610765764.html">GreenDao 3.3.0 多表关联使用（二）</a></li>
                
                <li><a title="GreenDao 3.3.0 增删改查的使用（三）" href="16280610843145.html">GreenDao 3.3.0 增删改查的使用（三）</a></li>
                 
                <li class="side-title"><span>组件化</span></li>
                
                <li><a title="组件化架构之解决Common组件中心化问题(api化方案)" href="16280609309201.html">组件化架构之解决Common组件中心化问题(api化方案)</a></li>
                 
            </ul>
        </div>
        <div class="columns"> 


	
		<div class="markdown-body">
		<h1>GreenDao 3.3.0 基本使用与入门 （一）</h1>

		<ul>
<li>
<a href="#toc_0">引入GreenDao</a>
</li>
<li>
<a href="#toc_1">Entity 注解详解</a>
<ul>
<li>
<a href="#toc_2">属性：</a>
</li>
<li>
<a href="#toc_3">@Id</a>
</li>
<li>
<a href="#toc_4">@Index</a>
</li>
<li>
<a href="#toc_5">@OrderBy</a>
</li>
<li>
<a href="#toc_6">@Property</a>
</li>
<li>
<a href="#toc_7">@NotNull</a>
</li>
<li>
<a href="#toc_8">@Transient</a>
</li>
<li>
<a href="#toc_9">@Unique</a>
</li>
<li>
<a href="#toc_10">@Property 建表字段命名</a>
</li>
<li>
<a href="#toc_11">GreenDao 3.3.0版本 设置默认值</a>
</li>
<li>
<a href="#toc_12">@Transient 注解</a>
</li>
<li>
<a href="#toc_13">实体类实现 Serializable 报错</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">DaoMaster DaoSession 数据操作和表管理</a>
</li>
</ul>


<h1 id="toc_0">引入GreenDao</h1>

<blockquote>
<p>Porject 目录下 build.gradle 下添加配置</p>
</blockquote>

<pre><code class="language-gradle">    dependencies {
        classpath &#39;com.android.tools.build:gradle:4.0.0&#39;
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
        classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.8&#39;//dagger2 apt 配置

        classpath &#39;org.greenrobot:greendao-gradle-plugin:3.3.0&#39; //add plugin greendao配置
     
    }
</code></pre>

<blockquote>
<p>接下来在module的 build.gradle 中添加</p>
</blockquote>

<pre><code class="language-gradle">apply plugin: &#39;org.greenrobot.greendao&#39; // apply plugin

android{
    ...
       greendao {

        schemaVersion 5  //数据库版本号，升级数据库需要修改版本号

        daoPackage &#39;com.greendao.dao&#39;  //一般为app包名+生成文件的文件夹名

        targetGenDir &#39;src/main/java&#39;  //自动生成的greendao代码存放路径

    }
    
}

dependencies {
    implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;])
    implementation &#39;androidx.appcompat:appcompat:1.1.0&#39;
    implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39;

    implementation &#39;org.greenrobot:greendao:3.3.0&#39; // add greendao library
    ....
}

</code></pre>

<blockquote>
<p>这样就完成GreenDao的引入了</p>
</blockquote>

<h1 id="toc_1">Entity 注解详解</h1>

<blockquote>
<p>@Entity<br/>
表明这个实体类会在数据库中生成一个与之相对应的表</p>
</blockquote>

<h2 id="toc_2">属性：</h2>

<ul>
<li>schema：告知GreenDao当前实体属于哪个 schema</li>
<li>schema active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法</li>
<li>nameInDb：在数据库中使用的别名，默认使用的是实体的类名</li>
<li>indexes：定义索引，可以跨越多个列</li>
<li>createInDb：标记创建数据库表（默认：true）</li>
<li>generateConstructors 自动创建全参构造方法（同时会生成一个无参构造方法）（默认：true）</li>
<li>generateGettersSetters 自动生成 getters and setters 方法（默认：true）</li>
</ul>

<pre><code class="language-java">@Entity(
        schema = &quot;myschema&quot;,
        active = true,
        nameInDb = &quot;AWESOME_USERS&quot;，
        indexes = {
                @Index(value = &quot;name DESC&quot;, unique = true)
        },
        createInDb = true,
        generateConstructors = false,
        generateGettersSetters = true
)
public class User {
  ...
}
</code></pre>

<h2 id="toc_3">@Id</h2>

<blockquote>
<p>对应数据表中的 Id 字段</p>
</blockquote>

<pre><code class="language-java">@Entity
public class UserList {
    @Id(autoincrement = true)//主键自动增长
    private Long id;
</code></pre>

<h2 id="toc_4">@Index</h2>

<blockquote>
<p>使用@Index作为一个属性来创建一个索引，默认是使用字段名</p>
</blockquote>

<pre><code class="language-java">@Entity
public class User {
    @Id 
    private Long id;

    @Index(unique = true)
    private String name;
}
</code></pre>

<h2 id="toc_5">@OrderBy</h2>

<blockquote>
<p>某一字段排序 ，例如：@OrderBy(“date ASC”)</p>
</blockquote>

<pre><code class="language-java">@OrderBy(&quot;date ASC&quot;)
private List&lt;Order&gt; orders;
</code></pre>

<h2 id="toc_6">@Property</h2>

<blockquote>
<p>设置一个非默认关系映射所对应的列名，默认是使用字段名,例如：</p>
</blockquote>

<pre><code class="language-java">@Entity (nameInDb = “User”)
public class User {
@Property(nameInDb = “userName”)
private String userName;

}
</code></pre>

<h2 id="toc_7">@NotNull</h2>

<blockquote>
<p>设置数据库表当前列不能为空</p>
</blockquote>

<h2 id="toc_8">@Transient</h2>

<blockquote>
<p>添加此标记后不会生成数据库表的列</p>
</blockquote>

<h2 id="toc_9">@Unique</h2>

<blockquote>
<p>表名该属性在数据库中只能有唯一值</p>
</blockquote>

<pre><code class="language-java">@Entity 
public class User {
@Id 
private Long id;
@Unique 
private String name;
}
</code></pre>

<p><strong>注意事项</strong></p>

<blockquote>
<p>由于greenDAO 3.0 生成的字段添加了非空约束。字段的类型设置为基本类型(如:int)默认会添加非空约束,字段类型设置为对象类型(如:Integer)默认不会添加非空约束,而且最终生成的sql会使用对象类型</p>

<p>定义int类型</p>
</blockquote>

<pre><code class="language-java">@Entity
public class CommentList {
    @Id(autoincrement = true)
    private Long id;
    private int sendId =0;//发送方ID
    private int receiveId;//接收方ID
  
  //------ CommentListDao.java  ------ 
   
        /** Creates the underlying database table. */
    public static void createTable(Database db, boolean ifNotExists) {
        String constraint = ifNotExists? &quot;IF NOT EXISTS &quot;: &quot;&quot;;
        db.execSQL(&quot;CREATE TABLE &quot; + constraint + &quot;\&quot;COMMENT_LIST\&quot; (&quot; + //
                &quot;\&quot;_id\&quot; INTEGER PRIMARY KEY AUTOINCREMENT ,&quot; + // 0: id
                &quot;\&quot;SEND_ID\&quot; INTEGER NOT NULL ,&quot; + // 1: sendId
                &quot;\&quot;RECEIVE_ID\&quot; INTEGER NOT NULL ,&quot; + // 2: receiveId
                &quot;\&quot;SEND_TYPE\&quot; INTEGER NOT NULL ,&quot; + // 3: sendType
</code></pre>

<blockquote>
<p>定义Integer类型</p>
</blockquote>

<pre><code class="language-java">@Entity
public class CommentList {
    @Id(autoincrement = true)
    private Long id;
    private Integer sendId =0;//发送方ID
    private Integer receiveId=0;//接收方ID
    private Integer sendType=0;//发送方用户类型
    
    // ------ CommentListDao.java  ------ 
    
    /** Creates the underlying database table. */
    public static void createTable(Database db, boolean ifNotExists) {
        String constraint = ifNotExists? &quot;IF NOT EXISTS &quot;: &quot;&quot;;
        db.execSQL(&quot;CREATE TABLE &quot; + constraint + &quot;\&quot;COMMENT_LIST\&quot; (&quot; + //
                &quot;\&quot;_id\&quot; INTEGER PRIMARY KEY AUTOINCREMENT ,&quot; + // 0: id
                &quot;\&quot;SEND_ID\&quot; INTEGER,&quot; + // 1: sendId
                &quot;\&quot;RECEIVE_ID\&quot; INTEGER,&quot; + // 2: receiveId
                &quot;\&quot;SEND_TYPE\&quot; INTEGER,&quot; + // 3: sendType
                &quot;\&quot;RECEIVE_TYPE\&quot; INTEGER,&quot; + // 4: receiveType
</code></pre>

<h2 id="toc_10">@Property 建表字段命名</h2>

<blockquote>
<p>使用@Entity建表的时候,默认情况下所有的表名和字段名都是大写的,使用nameInDb 定义表名和列名</p>
</blockquote>

<pre><code class="language-java">@Entity(nameInDb =&quot;User&quot;)
public class User implements Serializable {
    @Transient
    private static final long serialVersionUID = 1L;

    @Id(autoincrement = true )
    private Long id;
    @Property(nameInDb = &quot;name&quot;)
    private String name=&quot;Tom&quot;;
</code></pre>

<h2 id="toc_11">GreenDao 3.3.0版本 设置默认值</h2>

<blockquote>
<p>默认GreenDao 是没有默认值得,网上说作者不屑于设置,网上搜索后,有很多是修改自动生成的xxxDao 里面的 createTable 中的建表SQL语句</p>
</blockquote>

<pre><code class="language-java">    /** Creates the underlying database table. */
    public static void createTable(Database db, boolean ifNotExists) {
        String constraint = ifNotExists? &quot;IF NOT EXISTS &quot;: &quot;&quot;;
        db.execSQL(&quot;CREATE TABLE &quot; + constraint + &quot;\&quot;USER\&quot; (&quot; + //
                &quot;\&quot;_id\&quot; INTEGER PRIMARY KEY AUTOINCREMENT ,&quot; + // 0: id
                &quot;\&quot;NAME\&quot; TEXT,&quot; + // 1: name
                &quot;\&quot;AGE\&quot; INTEGER NOT NULL ,&quot; + // 2: age
                &quot;\&quot;SEX\&quot; TEXT,&quot; + // 3: sex
                &quot;\&quot;HEIGHT\&quot; INTEGER NOT NULL ,&quot; + // 4: height
                &quot;\&quot;WEIGHT\&quot; TEXT);&quot;); // 5: weight
    }
</code></pre>

<blockquote>
<p>也许由于版本的不同,反正3.3没有成功,Android Studio 执行Make Project后还原成原先建表语句,还有人说是修改实体类</p>
</blockquote>

<pre><code class="language-java">@Entity
public class User {
    @Id(autoincrement = true)
    private Long id;
    private String name=&quot;Tom&quot;;
    private int age=0;
    private String sex;
    private int height;
    private String weight;

</code></pre>

<blockquote>
<p>这里有一个坑,这样的方式是可行的,但是如果你这里修改后,去观察UserDao中的建表语句,还是和之前一样是没有变化的.并没有带上 Default 默认值</p>

<p>这样修改后,在插入一条数据,不带默认值的字段赋值后查看数据表,就会发现默认值已经有了,但是UserDao的建表语句还是原来的</p>
</blockquote>

<h2 id="toc_12">@Transient 注解</h2>

<blockquote>
<p>该注解用于当实体类中有字段不添加到数据表时使用</p>
</blockquote>

<pre><code class="language-java">@Entity
public class User implements Serializable {
    @Transient
    private static final long serialVersionUID = 1L;
    @Id(autoincrement = true)
    private Long id
    
</code></pre>

<h2 id="toc_13">实体类实现 Serializable 报错</h2>

<blockquote>
<p>这个时候添加一行<br/>
@Transient<br/>
private static final long serialVersionUID = 1L;</p>
</blockquote>

<h1 id="toc_14">DaoMaster DaoSession 数据操作和表管理</h1>

<blockquote>
<p>按照上面操作后Build&gt; make project后再自动生成Dao的时候还会生成</p>
</blockquote>

<ul>
<li>DaoMaster 建表注册管理表</li>
<li>DaoSession 对表进行增删改查</li>
</ul>

<pre><code class="language-java">public class GreenDBManager implements IDBManager {
    private static final String DB_NAME = &quot;User.db&quot;; //数据库名
    private DaoSession mDaoSession;
    //private UserTableManager mUserTableManager;
    private TablesComponent mTablesComponent;
    private DaoMaster daoMaster;

 
      public GreenDBManager init(Application application, String dbName) {
        Integer dbVersion = DaoMaster.SCHEMA_VERSION;
        mApplication = application;
       
        Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;[] classes = new Class[]{UserDao.class, UserListDao.class};

        //DBUpdateOpenHelper对DaoMaster进行初始化，这样就可以实现数据库升级时的数据迁移
     
        DBUpdateOpenHelper updateOpenHelper = new DBUpdateOpenHelper(application, dbName, mclasses);
        daoMaster = new DaoMaster(updateOpenHelper.getWritableDatabase());

        //9.0的数据库默认启用了wal，用低版本的sqlite工具是无法查看的，想要兼容可以禁用wal
        updateOpenHelper.getWritableDatabase().disableWriteAheadLogging();//启用 enableWriteAheadLogging
        mDaoSession = daoMaster.newSession();

        //查看数据库更新版本时数据迁移的log
        MigrationHelper.DEBUG = false;
        //数据库增删改查时的log
        QueryBuilder.LOG_SQL = false;
        QueryBuilder.LOG_VALUES = false;
        //清空缓存
        mDaoSession.clear();

        return this;
    }

    
     @Override
    public DaoSession getDaoSession() {
        if (mDaoSession==null){
            mDaoSession=daoMaster.newSession();
        }
        return mDaoSession;
    }
 
</code></pre>

<blockquote>
<p>在Application 里面初始化init后,就可通过 getDaoSession 对所有表进行操作处理了</p>

<p>DBUpdateOpenHelper.java</p>
</blockquote>

<pre><code class="language-java">public class DBUpdateOpenHelper extends DaoMaster.OpenHelper {
    Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;[] mDaoClasses;
    public DBUpdateOpenHelper(Context context, String name, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        super(context, name);
        mDaoClasses=daoClasses;
    }

    public DBUpdateOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        super(context, name, factory);
        mDaoClasses=daoClasses;
    }
    @Override
    public void onCreate(Database db) {
        DaoMaster.createAllTables(db, false);
    }

    @Override
    public void onUpgrade(Database db, int oldVersion, int newVersion) {

        //把需要管理的数据库表DAO作为最后一个参数传入到方法中
        MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() {

            @Override
            public void onCreateAllTables(Database db, boolean ifNotExists) {
                DaoMaster.createAllTables(db, ifNotExists);
            }

            @Override
            public void onDropAllTables(Database db, boolean ifExists) {
                DaoMaster.dropAllTables(db, ifExists);
            }
        }, mDaoClasses);
    }
}
</code></pre>

<blockquote>
<p>MigrationHelper.java 用于数据库升级时数据迁移</p>
</blockquote>

<pre><code class="language-java">package com.zk.greendb.helper;

import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.text.TextUtils;
import android.util.Log;

import org.greenrobot.greendao.AbstractDao;
import org.greenrobot.greendao.database.Database;
import org.greenrobot.greendao.database.StandardDatabase;
import org.greenrobot.greendao.internal.DaoConfig;

import java.lang.ref.WeakReference;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 用于数据库升级时数据迁移
 * from https://github.com/yuweiguocn/GreenDaoUpgradeHelper
 *
 * please call {@link #migrate(SQLiteDatabase, Class[])} or {@link #migrate(Database, Class[])}
 */
public class MigrationHelper {

    public static boolean DEBUG = false;
    private static final String TAG= MigrationHelper.class.getSimpleName();
    private static final String SQLITE_MASTER = &quot;sqlite_master&quot;;
    private static final String SQLITE_TEMP_MASTER = &quot;sqlite_temp_master&quot;;

    private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener;

    public interface ReCreateAllTableListener{
        void onCreateAllTables(Database db, boolean ifNotExists);
        void onDropAllTables(Database db, boolean ifExists);
    }

    public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        printLog(&quot;【The Old Database Version】&quot; + db.getVersion());
        Database database = new StandardDatabase(db);
        migrate(database, daoClasses);
    }

    public static void migrate(SQLiteDatabase db, MigrationHelper.ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        weakListener = new WeakReference&lt;&gt;(listener);
        migrate(db, daoClasses);
    }

    public static void migrate(Database database, MigrationHelper.ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        weakListener = new WeakReference&lt;&gt;(listener);
        migrate(database, daoClasses);
    }

    public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        printLog(&quot;【Generate temp table】start&quot;);
        generateTempTables(database, daoClasses);
        printLog(&quot;【Generate temp table】complete&quot;);

        MigrationHelper.ReCreateAllTableListener listener = weakListener.get();
        if (listener != null) {
            listener.onDropAllTables(database, true);
            printLog(&quot;【Drop all table by listener】&quot;);
            listener.onCreateAllTables(database, false);
            printLog(&quot;【Create all table by listener】&quot;);
        } else {
            dropAllTables(database, true, daoClasses);
            createAllTables(database, false, daoClasses);
        }
        printLog(&quot;【Restore data】start&quot;);
        restoreData(database, daoClasses);
        printLog(&quot;【Restore data】complete&quot;);
    }

    private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        for (int i = 0; i &lt; daoClasses.length; i++) {
            String tempTableName = null;

            DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);
            String tableName = daoConfig.tablename;
            if (!isTableExists(db, false, tableName)) {
                printLog(&quot;【New Table】&quot; + tableName);
                continue;
            }
            try {
                tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);
                StringBuilder dropTableStringBuilder = new StringBuilder();
                dropTableStringBuilder.append(&quot;DROP TABLE IF EXISTS &quot;).append(tempTableName).append(&quot;;&quot;);
                db.execSQL(dropTableStringBuilder.toString());

                StringBuilder insertTableStringBuilder = new StringBuilder();
                insertTableStringBuilder.append(&quot;CREATE TEMPORARY TABLE &quot;).append(tempTableName);
                insertTableStringBuilder.append(&quot; AS SELECT * FROM &quot;).append(tableName).append(&quot;;&quot;);
                db.execSQL(insertTableStringBuilder.toString());
                printLog(&quot;【Table】&quot; + tableName +&quot;\n ---Columns--&gt;&quot;+getColumnsStr(daoConfig));
                printLog(&quot;【Generate temp table】&quot; + tempTableName);
            } catch (SQLException e) {
                Log.e(TAG, &quot;【Failed to generate temp table】&quot; + tempTableName, e);
            }
        }
    }

    private static boolean isTableExists(Database db, boolean isTemp, String tableName) {
        if (db == null || TextUtils.isEmpty(tableName)) {
            return false;
        }
        String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER;
        String sql = &quot;SELECT COUNT(*) FROM &quot; + dbName + &quot; WHERE type = ? AND name = ?&quot;;
        Cursor cursor=null;
        int count = 0;
        try {
            cursor = db.rawQuery(sql, new String[]{&quot;table&quot;, tableName});
            if (cursor == null || !cursor.moveToFirst()) {
                return false;
            }
            count = cursor.getInt(0);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null)
                cursor.close();
        }
        return count &gt; 0;
    }


    private static String getColumnsStr(DaoConfig daoConfig) {
        if (daoConfig == null) {
            return &quot;no columns&quot;;
        }
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i &lt; daoConfig.allColumns.length; i++) {
            builder.append(daoConfig.allColumns[i]);
            builder.append(&quot;,&quot;);
        }
        if (builder.length() &gt; 0) {
            builder.deleteCharAt(builder.length() - 1);
        }
        return builder.toString();
    }


    public static void dropAllTables(Database db, boolean ifExists, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        reflectMethod(db, &quot;dropTable&quot;, ifExists, daoClasses);
        printLog(&quot;【Drop all table by reflect】&quot;);
    }

    public static void createAllTables(Database db, boolean ifNotExists,  Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        reflectMethod(db, &quot;createTable&quot;, ifNotExists, daoClasses);
        printLog(&quot;【Create all table by reflect】&quot;);
    }

    /**
     * dao class already define the sql exec method, so just invoke it
     */
    private static void reflectMethod(Database db, String methodName, boolean isExists,  Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        if (daoClasses.length &lt; 1) {
            return;
        }
        try {
            for (Class cls : daoClasses) {
                Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class);
                method.invoke(null, db, isExists);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) {
        for (int i = 0; i &lt; daoClasses.length; i++) {
            DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);
            String tableName = daoConfig.tablename;
            String tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);

            if (!isTableExists(db, true, tempTableName)) {
                continue;
            }

            try {
                // get all columns from tempTable, take careful to use the columns list
                List&lt;String&gt; columns = getColumns(db, tempTableName);
                ArrayList&lt;String&gt; properties = new ArrayList&lt;&gt;(columns.size());
                for (int j = 0; j &lt; daoConfig.properties.length; j++) {
                    String columnName = daoConfig.properties[j].columnName;
                    if (columns.contains(columnName)) {
                        properties.add(columnName);
                    }
                }
                if (properties.size() &gt; 0) {
                    final String columnSQL = TextUtils.join(&quot;,&quot;, properties);

                    StringBuilder insertTableStringBuilder = new StringBuilder();
                    insertTableStringBuilder.append(&quot;INSERT INTO &quot;).append(tableName).append(&quot; (&quot;);
                    insertTableStringBuilder.append(columnSQL);
                    insertTableStringBuilder.append(&quot;) SELECT &quot;);
                    insertTableStringBuilder.append(columnSQL);
                    insertTableStringBuilder.append(&quot; FROM &quot;).append(tempTableName).append(&quot;;&quot;);
                    db.execSQL(insertTableStringBuilder.toString());
                    printLog(&quot;【Restore data】 to &quot; + tableName);
                }
                StringBuilder dropTableStringBuilder = new StringBuilder();
                dropTableStringBuilder.append(&quot;DROP TABLE &quot;).append(tempTableName);
                db.execSQL(dropTableStringBuilder.toString());
                printLog(&quot;【Drop temp table】&quot; + tempTableName);
            } catch (SQLException e) {
                Log.e(TAG, &quot;【Failed to restore data from temp table 】&quot; + tempTableName, e);
            }
        }
    }

    private static List&lt;String&gt; getColumns(Database db, String tableName) {
        List&lt;String&gt; columns = null;
        Cursor cursor = null;
        try {
            cursor = db.rawQuery(&quot;SELECT * FROM &quot; + tableName + &quot; limit 0&quot;, null);
            if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) {
                columns = Arrays.asList(cursor.getColumnNames());
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (cursor != null)
                cursor.close();
            if (null == columns)
                columns = new ArrayList&lt;&gt;();
        }
        return columns;
    }

    private static void printLog(String info){
        if(DEBUG){
            Log.d(TAG, info);
        }
    }
}
</code></pre>


		</div>
	

 
	

 
	

  
  </div>
</div>


<div class="page-bottom">
    <div class="copyright">
        <a href="mailto:888api@sina.com">郝彬彬</a> &copy; 
    </div>
    <div class="copyright text-right">
        <a href="#main-content">TOP</a>
    </div>
</div>

</div>




  














<style type="text/css">
    figure {
        margin: 0.4em 0;
        padding: 0;
    }
    
    figcaption {
        text-align: center;
    }
    /* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
    /**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */
    
    code[class*="language-"],
    pre[class*="language-"] {
        color: black;
        background: none;
        text-shadow: 0 1px white;
        font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
        text-align: left;
        white-space: pre;
        word-spacing: normal;
        word-break: normal;
        word-wrap: normal;
        line-height: 1.5;
        -moz-tab-size: 4;
        -o-tab-size: 4;
        tab-size: 4;
        -webkit-hyphens: none;
        -moz-hyphens: none;
        -ms-hyphens: none;
        hyphens: none;
    }
    
    pre[class*="language-"]::-moz-selection,
    pre[class*="language-"] ::-moz-selection,
    code[class*="language-"]::-moz-selection,
    code[class*="language-"] ::-moz-selection {
        text-shadow: none;
        background: #b3d4fc;
    }
    
    pre[class*="language-"]::selection,
    pre[class*="language-"] ::selection,
    code[class*="language-"]::selection,
    code[class*="language-"] ::selection {
        text-shadow: none;
        background: #b3d4fc;
    }
    
    @media print {
        code[class*="language-"],
        pre[class*="language-"] {
            text-shadow: none;
        }
    }
    /* Code blocks */
    
    pre[class*="language-"] {
        padding: 1em;
        margin: .5em 0;
        overflow: auto;
    }
    
     :not(pre)>code[class*="language-"],
    pre[class*="language-"] {
        background: #F7F7F7;
    }
    /* Inline code */
    
     :not(pre)>code[class*="language-"] {
        padding: .1em;
        border-radius: .3em;
        white-space: normal;
    }
    
    .token.comment,
    .token.prolog,
    .token.doctype,
    .token.cdata {
        color: slategray;
    }
    
    .token.punctuation {
        color: #999;
    }
    
    .namespace {
        opacity: .7;
    }
    
    .token.property,
    .token.tag,
    .token.boolean,
    .token.number,
    .token.constant,
    .token.symbol,
    .token.deleted {
        color: #905;
    }
    
    .token.selector,
    .token.attr-name,
    .token.string,
    .token.char,
    .token.builtin,
    .token.inserted {
        color: #690;
    }
    
    .token.operator,
    .token.entity,
    .token.url,
    .language-css .token.string,
    .style .token.string {
        color: #9a6e3a;
        background: hsla(0, 0%, 100%, .5);
    }
    
    .token.atrule,
    .token.attr-value,
    .token.keyword {
        color: #07a;
    }
    
    .token.function,
    .token.class-name {
        color: #DD4A68;
    }
    
    .token.regex,
    .token.important,
    .token.variable {
        color: #e90;
    }
    
    .token.important,
    .token.bold {
        font-weight: bold;
    }
    
    .token.italic {
        font-style: italic;
    }
    
    .token.entity {
        cursor: help;
    }
    
    pre[class*="language-"].line-numbers {
        position: relative;
        padding-left: 3.8em;
        counter-reset: linenumber;
    }
    
    pre[class*="language-"].line-numbers>code {
        position: relative;
        white-space: inherit;
    }
    
    .line-numbers .line-numbers-rows {
        position: absolute;
        pointer-events: none;
        top: 0;
        font-size: 100%;
        left: -3.8em;
        width: 3em;
        /* works for line-numbers below 1000 lines */
        letter-spacing: -1px;
        border-right: 1px solid #999;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    .line-numbers-rows>span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }
    
    .line-numbers-rows>span:before {
        content: counter(linenumber);
        color: #999;
        display: block;
        padding-right: 0.8em;
        text-align: right;
    }
</style>

<script src="asset/js/foundation.min.js"></script>
<script src="asset/js/foundation/foundation.offcanvas.js"></script>
<script>
    $(document).foundation();
</script>
<script src="asset/js/watermark.js"></script>

</body>

</html>