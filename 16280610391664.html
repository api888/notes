<!doctype html>
<html class="no-js" lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        烂笔头
    </title>
    <meta name="description" content="">
    <link href="atom.xml" rel="alternate" title="烂笔头" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>
        hljs.initHighlightingOnLoad();
    </script>

</head>

<body class="antialiased hide-extras"></body>

<div class="inner-wrap">


    <nav class="top-bar docs-bar hide-for-small" data-topbar>

        <div id="header">
            <h1><a href="index.html">烂笔头</a></h1>
        </div>

    </nav>


    <div class="row">
        <div class="sidebar">
            <ul id="side-nav" class="side-nav">

                
                <li class="side-title"><span>Android</span></li>
                
                <li><a title="移除第三方SDK所声明的权限" href="16280619241100.html">移除第三方SDK所声明的权限</a></li>
                
                <li><a title="Android登录页面，未勾选用户协议、隐私政策出现抖动效果" href="16280609822586.html">Android登录页面，未勾选用户协议、隐私政策出现抖动效果</a></li>
                
                <li><a title="DialogFragment内存泄露问题能不能一次性改好" href="16251021954820.html">DialogFragment内存泄露问题能不能一次性改好</a></li>
                
                <li><a title="Android静默安装实现方案，仿360手机助手秒装和智能安装功能" href="16251021954779.html">Android静默安装实现方案，仿360手机助手秒装和智能安装功能</a></li>
                
                <li><a title="Android 添加水印功能" href="16251021954737.html">Android 添加水印功能</a></li>
                
                <li><a title="Android 监听手电筒状态" href="16251021954689.html">Android 监听手电筒状态</a></li>
                 
                <li class="side-title"><span>Github</span></li>
                
                <li><a title="使用Github+jsdelivr构建你的免费图床" href="16251022060206.html">使用Github+jsdelivr构建你的免费图床</a></li>
                 
                <li class="side-title"><span>Glide</span></li>
                
                <li><a title="Glide源码修改-自定义磁盘缓存实现永久存储" href="16251022251608.html">Glide源码修改-自定义磁盘缓存实现永久存储</a></li>
                
                <li><a title="Android—Glide使用教程（一）" href="16251022251568.html">Android—Glide使用教程（一）</a></li>
                
                <li><a title="Android—Glide使用教程（二）" href="16251022251484.html">Android—Glide使用教程（二）</a></li>
                
                <li><a title="Android—Glide使用教程（三）" href="16251022251527.html">Android—Glide使用教程（三）</a></li>
                 
                <li class="side-title"><span>Gradle</span></li>
                
                <li><a title="Gradle 自定义Plugin插件之上传APK到蒲公英" href="16280610391708.html">Gradle 自定义Plugin插件之上传APK到蒲公英</a></li>
                
                <li><a title="自定义Gradle Plugin，优雅的解决第三方Jar包中的bug" href="16280610391664.html">自定义Gradle Plugin，优雅的解决第三方Jar包中的bug</a></li>
                
                <li><a title="如何使用Android Studio开发Gradle插件" href="16280610391616.html">如何使用Android Studio开发Gradle插件</a></li>
                
                <li><a title="sourceSets使用" href="16251022385733.html">sourceSets使用</a></li>
                
                <li><a title="脑洞大开，Gradle项目管理依赖的船新版本" href="16251022385689.html">脑洞大开，Gradle项目管理依赖的船新版本</a></li>
                 
                <li class="side-title"><span>Rxjava</span></li>
                
                <li><a title="RxJava2 只看这一篇文章就够了" href="16251022491138.html">RxJava2 只看这一篇文章就够了</a></li>
                 
                <li class="side-title"><span>GreenDAO</span></li>
                
                <li><a title="GreenDao 3.3.0 基本使用与入门 （一）" href="16280610693006.html">GreenDao 3.3.0 基本使用与入门 （一）</a></li>
                
                <li><a title="GreenDao 3.3.0 多表关联使用（二）" href="16280610765764.html">GreenDao 3.3.0 多表关联使用（二）</a></li>
                
                <li><a title="GreenDao 3.3.0 增删改查的使用（三）" href="16280610843145.html">GreenDao 3.3.0 增删改查的使用（三）</a></li>
                 
                <li class="side-title"><span>组件化</span></li>
                
                <li><a title="组件化架构之解决Common组件中心化问题(api化方案)" href="16280609309201.html">组件化架构之解决Common组件中心化问题(api化方案)</a></li>
                 
            </ul>
        </div>
        <div class="columns"> <div id="main-content" class="markdown-body">
    <h1>自定义Gradle Plugin，优雅的解决第三方Jar包中的bug</h1>

    <ul>
<li>
<a href="#toc_0">上篇</a>
</li>
<li>
<a href="#toc_1">中篇</a>
</li>
<li>
<a href="#toc_2">下篇</a>
</li>
</ul>


<h1 id="toc_0">上篇</h1>

<p>我们在开发中经常用到一些优秀的第三方库，比如okhttp，glide，butterknife等。这些库不仅提高了开发效率而且避免踩坑，假如在应用中这些开源库出现了bug，我们随时可以从GitHub下载源码进行bug修改。但是项目中使用的库不是开源的并且该库又存在bug，由于没有源码也就无法进行bug的修复，一般做法就是给非开源库的作者或组织反馈bug等他们进行修复，如果他们修复的及时还好说，一旦他们更新不及时就会给我们APP造成不好影响(比如用户流失)……这篇文章我就给小伙伴们讲解一下如何自定义Gradle Plugin来彻底解决第三方Jar包中的bug(<em><sup>__^</sup></em>) ……</p>

<p>入职新公司以来一直把精力放在了新公司原有项目的重构上，与其说是重构还不如说是重写了一遍，重构期间整个Android团队压力还是蛮大的，一方面在开发新需求另一方面在进行项目重构，经过几个月的辛劳重构后，新项目顺利上线了(在这里对整个团队表示感谢)，重构后的新版本上线后我一直在Bugly上关注着它的稳定情况，尤其是崩溃率。从Bugly的日志上我发现有几个crash从旧版本到重构后的新版本一直存在着，且这些crash都是发生在第三方Jar包中的，其中一个crash日志如下所示：</p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/20171118214457373.png" alt=""/></p>

<p>日志信息清楚的表明该crash是用户没有授权导致的，由于我们APP集成了企鹅厂家的直播SDK，在用户退出直播间后都会调用SDK的退出直播间方法，也就是说崩溃发生在鹅厂的SDK内部，尽管我们在进入APP中都有向用户申请READ_PHONE_STATE权限，但还是存在部分用户不予授权的情况，以上crash就是用户没有授权导致的。因此我把这个问题反馈给了鹅厂的SDK研发组那里，并问他们能不能做下兼容(就是添加权限的判断)，他们很快给予了回复说没法做兼容并给了个解决办法：如果用户没授权就给用户提示然后强制退出APP。如果按照鹅厂的解决办法那就代表着用户不授予权限就不能使用我们APP了，这显然是不可接受的，因为这样很容易造成用户流失……</p>

<p>既然鹅厂那边不愿意解决该问题，那我自己来解决！！！在解决该问题前我们先看看他们SDK中NetworkHelp类下的getAPInfo()方法和getMobileAPInfo()方法实现逻辑是什么样的，因为从Bugly日志看崩溃前调用了NetworkHelp中的这俩方法。反编译NetworkHelp.class文件，核心代码如下所示：</p>

<pre><code class="language-java">public class NetworkHelp {
 
    protected static NetworkHelp.APInfo getAPInfo(Context var0) {
        NetworkHelp.APInfo var1 = new NetworkHelp.APInfo();
        if(var0 == null) {
            QLog.e(&quot;NetworkHelp&quot;, 0, &quot;getAPInfo initial context is null&quot;);
            return var1;
        } else {
            ConnectivityManager var2 = (ConnectivityManager)var0.getSystemService(&quot;connectivity&quot;);
            NetworkInfo var3 = var2.getActiveNetworkInfo();
            if(var3 != null &amp;&amp; var3.isConnected()) {
                switch(var3.getType()) {
                case 0:
                    // 在这里调用了getMobileAPInfo()方法
                    var1 = getMobileAPInfo(var0, var3.getSubtype());
                    break;
                // 省略相关代码......
            }
 
            return var1;
        }
    }
 
    private static NetworkHelp.APInfo getMobileAPInfo(Context var0, int var1) {
        TelephonyManager var2 = (TelephonyManager)var0.getSystemService(&quot;phone&quot;);
        NetworkHelp.MobileCarrier var3 = NetworkHelp.MobileCarrier.UNKNOWN;
        String var4 = var2.getSubscriberId(); // getSubscriberId()内部抛的异常
        
        // 省略相关代码...
 
        NetworkHelp.APInfo var5 = new NetworkHelp.APInfo();
        
        // 省略相关代码...
 
        return var5;
    }
 
    public static class APInfo {
        public int apType;
        public String apName;
 
        public APInfo() {// 当创建该对象的时候，属性会赋予默认值
            this.apType = NetworkHelp.APType.AP_UNKNOWN.value();
            this.apName = &quot;AP_UNKNOWN&quot;;
        }
    }
 
    // 省略相关代码...
}
</code></pre>

<p>根据反编译的NetworkHelp源码可以看出在getAPInfo()方法中首先判断Context类型的参数var0是否为null，如果为null则直接返回APInfo对象，而APInfo对象在创建的时候会把内部属性赋予默认值，也就是说如果我们在getAPInfo()方法中想办法让参数var0为null不就可以避免那些没有授权的用户发生崩溃了么？这是一个Hook点，简单粗暴(<em><sup>__^</sup></em>) ……我们继续往下读getAPInfo()的代码，如果参数var0不为空且网络是OK的，就会走到getMobileInfo()方法中，在getMobileInfo()方法中调用了TelephoneManager的getSubscriberId()方法，而getSubscriberId()方法内部执行过程中会做权限校验，在未授权的情况下会抛出异常，因此只要在getMobileInfo()方法中调用getSubscriberId()前添加判断是否有权限的代码块就OK了，这又是一个Hook点(<em><sup>__^</sup></em>) ……根据以上两个Hook点，我们对NetworkHelp做Hook后的代码应该是如下的样子：</p>

<pre><code class="language-java">public class NetworkHelp {
 
    protected static NetworkHelp.APInfo getAPInfo(Context var0) {
        // Hook点1，添加如下一句代码，简单粗暴
        var0 = null;
        NetworkHelp.APInfo var1 = new NetworkHelp.APInfo();
        if(var0 == null) {
            QLog.e(&quot;NetworkHelp&quot;, 0, &quot;getAPInfo initial context is null&quot;);
            return var1;
        } else {
 
            // 省略相关代码...
 
            return var1;
        }
    }
 
    private static NetworkHelp.APInfo getMobileAPInfo(Context var0, int var1) {
        // Hook点2，考虑SDK的感受，让他们拿到网络信息(*^__^*)
        if (PackageManager.PERMISSION_GRANTED != ContextCompat.checkSelfPermission(var0, Manifest.permission.READ_PHONE_STATE)) {
            return new NetworkHelp.APInfo();
        }
 
        TelephonyManager var2 = (TelephonyManager)var0.getSystemService(&quot;phone&quot;);
        NetworkHelp.MobileCarrier var3 = NetworkHelp.MobileCarrier.UNKNOWN;
        String var4 = var2.getSubscriberId(); // getSubscriberId()内部抛的异常
 
        // 省略相关代码...
 
        return var5;
    }
 
    // 省略相关代码...
}
</code></pre>

<p>好了，清楚了对NetworkHelp的Hook点后，接下来就是考虑如何对NetworkHelp.class类进行修改了，要修改class文件就要清楚JVM指令，因为class文件最后都是通过类加载器加载运行在JVM上的，只有清楚JVM指定才能按照JVM规范来修改class文件。好在这个世界总有那么一些神一般存在的大神，对于class文件的修改操作(添加方法，修改方法、字段等)已经有位日本的大学教授封装好了面向Java API编程的字节码操作库<a href="https://github.com/jboss-javassist/javassist">Javassist</a>，该库目前已收录于jboss开源项目中。使用<a href="https://github.com/jboss-javassist/javassist">Javassist</a>库就可以避免和JVM指令打交道，从而让修改class文件变得简单Happy起来。【注意：】这篇文章仅仅介绍<a href="https://github.com/jboss-javassist/javassist">Javassist</a>的简单用法，后续文章将介绍它的详细用法以及带领小伙伴来读一下<a href="https://github.com/jboss-javassist/javassist">Javassist</a>的源码，敬请期待……</p>

<p>有了操作class文件的<a href="https://github.com/jboss-javassist/javassist">Javassist</a>库，就可以对class文件进行修改了，修改流程是：首先解压第三方Jar文件，拿到要修复的class文件，其次利用<a href="https://github.com/jboss-javassist/javassist">Javassist</a>库进行class文件修改，修改完打包成Jar文件后覆盖原有的Jar文件，之后项目打包也就直接把修复过的Jar文件打包进去了。这个流程理论上是没有问题的，但是当我们引用的第三方Jar包是通过Gradle来配置的话就会存在冗余工作的问题，例如ConstraintLayout包：</p>

<pre><code class="language-groovy">compile &#39;com.android.support.constraint:constraint-layout:1.0.2&#39;
</code></pre>

<p>Gradle文件中添加如上配置后，它就会从JCenter仓库下载相应配置的Jar文件保存在以版本号命名的本地文件夹中，若按照上述流程进行class文件的修复是没有问题的，但是当ConstraintLayout进行了版本升级，这个时候Gradle就又会下载最新包到本地，这个时候我们又得从新执行以上的修复流程，这样十分繁琐，作为程序员一定要记住：能用机器去做的就坚决不要让人去做，自动化一切可以自动化的。所以我们的目标的是write once, run anywhere，无论依赖的Jar包今后升级与否，只写一遍代码就能统统搞定(<em><sup>__^</sup></em>) ……</p>

<p>既然要实现一次编码就能满足今后所依赖的Jar文件升级与否的功能，我们就要在项目打包成APK前找到一个节点，这个节点一定是在Jar包被转换成Dex文件前，因为在Gradle打包流程中一旦Jar包被转换成Dex文件后，我们再对Jar文件进行处理就已经失去意义了，好在Gradle plugin在1.5.0版本后给我们提供了<a href="http://tools.android.com/tech-docs/new-build-system/transform-api">API Transform</a>，该<a href="http://tools.android.com/tech-docs/new-build-system/transform-api">Transform</a>的作用如官方所说：</p>

<blockquote>
<p>Starting with 1.5.0-beta1, the Gradle plugin includes a Transform API allowing 3rd party plugins to manipulate compiled class files before they are converted to dex files. (The API existed in 1.4.0-beta2 but it&#39;s been completely revamped in 1.5.0-beta1)</p>
</blockquote>

<p>也就是说，Gradle Plugin 在1.5.0之后的版本中，Gradle Plugin提供了Transform API，该Transform API 允许第三方插件在class文件被转换成Dex文件之前有机会处理到这些class文件。</p>

<p>现在我们有了对class处理的<a href="https://github.com/jboss-javassist/javassist">Javassist</a>库，也找到了对class文件的处理时机，接下来就是自定义Gradle Plugin来实现对Jar文件的修复了。</p>

<p>首先在我们项目中创建一个Android Library Module取名为plugin，该plugin就是用来开发Gradle插件的。<br/>
然后清空plugin下的其他文件，只保留build.gradle和src/main目录，在build.gradle中添加如下配置：</p>

<pre><code class="language-groovy">apply plugin: &#39;groovy&#39;

repositories {
    jcenter()
}

dependencies {
    compile gradleApi()
    compile localGroovy()

    compile &#39;com.android.tools.build:gradle:2.3.3&#39;
    compile &#39;org.javassist:javassist:3.20.0-GA&#39;
}
</code></pre>

<p>添加以上配置后同步一下代码就OK了，这段配置代码主要是声明plugin插件使用的Gradle SDK和Groovy SDK并添加gradle和javassist API的依赖。</p>

<p>然后进入plugin目录下的main目录创建groovy目录，因为Gradle插件是基于Groovy语法的，因此我们开发的插件相当于一个Groovy项目，所以需要在main目录下创建groovy目录。这时plugin目录如下所示：</p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/20171117222828096.png" alt=""/></p>

<p>由于groovy是基于JVM的DSL语言，在groovy中能完美调用Java API。因此创建groovy文件和创建Java文件是类似的，在groovy包下新建包名：com.llew.bytecode.fix.plugin，然后在plugin包下新建BytecodeFixPlugin.groovy文件，因为要创建Gradle插件就必须要实现Gradle包中的org.gradle.api.Plugin接口，所以BytecodeFixPlugin.groovy内容如下所示：</p>

<pre><code class="language-groovy">package com.llew.bytecode.fix.plugin;
 
import org.gradle.api.Plugin;
import org.gradle.api.Project;
 
public class BytecodeFixPlugin implements Plugin&lt;Project&gt; {
 
    @Override
    void apply(Project project) {
        println &quot;this is a gradle plugin, (*^__^*)……&quot;
    }
}
</code></pre>

<p>插件定义好之后我们要告诉Gradle哪一个类是我们定义的插件类，因此需要在main目录下创建resources目录，然后在resources目录下创建META-INF目录，接着在META-INF目录下创建gradle-plugins目录，gradle-plugins目录是自定义Gradle插件的必备目录，然后在该目录下创建一个properties文件，文件名为com.llew.bytecode.fix.properties，这个文件名是有技巧的，当起完名字后如果要使用插件，就可以这样：apply plugin &#39;com.llew.bytecode.fix&#39;；起完名字后还不可以使用该插件，还要告诉Gradle自定义插件的具体实现类是哪一个，在com.llew.bytecode.fix.properties文件中添加如下内容：</p>

<pre><code class="language-text">implementation-class=com.llew.bytecode.fix.plugin.BytecodeFixPlugin
</code></pre>

<p>这样就告诉了Gradle插件的实现类是com.llew.bytecode.fix.plugin.BytecodeFixPlugin，定义完了以上配置后，还需要把插件打包到Maven仓库后才可以使用，为了简单起见，我们直接把插件打包到本地Maven仓库，在plugin的build.gradle中完整配置如下：</p>

<pre><code class="language-groovy">apply plugin: &#39;groovy&#39;
apply plugin: &#39;maven&#39;
 
repositories {
    jcenter()
    mavenCentral()
}
 
dependencies {
    compile gradleApi()
    compile localGroovy()
    compile &#39;com.android.tools.build:gradle:2.3.3&#39;
}
group   = &#39;com.llew.bytecode.fix&#39;
version = &#39;1.0.0&#39;
 
uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: uri(&quot;../repository&quot;))
        }
    }
}
</code></pre>

<p>配置好plugin的build.gradle后就是进行打包了，这时候点击Android Studio的gradle工具在plugin下有一个uploadArchives Task，这时候点击运行该task，就会在plugin的同级目录下生成一个repository文件夹，该文件夹就是plugin的仓库，如下图所示：</p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/20171117234942277.png" alt=""/></p>

<p>plugin打包到本地仓库后就可以在主项目的build.gradle中使用我们自定义的插件了，在根目录的build.gradle文件中添加Maven的本地依赖，代码如下所示：</p>

<pre><code class="language-groovy">buildscript {
    
    repositories {
        jcenter()
        maven {// 添加Maven的本地依赖
            url uri(&#39;./repository&#39;)
        }
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.3.3&#39;
        // 添加如下配置，格式为：groupName:moduleName:version
        classpath &#39;com.llew.bytecode.fix:plugin:1.0.0&#39;
    }
}
</code></pre>

<p>在根目录的build.gradle配置完成之后，就可以只用我们自定义的插件了，在主项目的build.gradle文件末尾中添加如下依赖：</p>

<pre><code class="language-groovy">apply plugin: &#39;com.llew.bytecode.fix&#39;
</code></pre>

<p>主项目的build.gradle配置完成后重新clean下代码，重新clean下代码，重新clean下代码，重要的事情说三遍，然后点击Android Studio的make project按钮，Gradle输出窗口就会打印如下日志：</p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/20171118000932631.png" alt=""/></p>

<p>经过一系列的操作，我们自定义的插件终于可以使用了，顿时感觉好Happy呀，哈哈，接下来就可以在我们自定义的插件BytecodeFixPlugin中注入Transform了，创建BytecodeFixTransform并继承Transform类，然后重写相关方法，代码如下：</p>

<pre><code class="language-groovy">package com.llew.bytecode.fix.transform
 
public class BytecodeFixTransform extends Transform {
 
    private static final String DEFAULT_NAME = &quot;BytecodeFixTransform&quot;
 
    BytecodeFixTransform() {
    }
 
    @Override
    public String getName() {
        return DEFAULT_NAME
    }
 
    @Override
    public Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {
        return TransformManager.CONTENT_CLASS
    }
 
    @Override
    public Set&lt;? super QualifiedContent.Scope&gt; getScopes() {
        return TransformManager.SCOPE_FULL_PROJECT
    }
 
    @Override
    public boolean isIncremental() {
        return false
    }
 
    @Override
    public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
    }
}
</code></pre>

<p>BytecodeFixTransform重写了部分方法，相关方法解释如下：</p>

<ul>
<li><p>getName()<br/>
该方法表示当前Transform在task列表中的名字，返回值最终经过一系列的拼接，具体拼接实现在TransformManager的<br/>
<code>getTaskNamePrefix()方法中，拼接格式：transform${InputType1}And${InputType2}And${InputTypeN}And${name}For${flavor}${BuildType}</code></p></li>
<li><p>getInputTypes()<br/>
该方法表示指定输入类型，这里我们指定CONTENT_CLASS类型</p></li>
<li><p>getScopes()<br/>
该方法表示当前Transform的作用范围，这里我们指定SCOPE_FULL_PROJECT</p></li>
<li><p>isIncremental()<br/>
该方法表示当前Transform是否支持增量编译</p></li>
<li><p>transform()<br/>
该方法是重点，它接收上一个Transform的输出，并把处理后的结果作为下一个Transform的输入，如下所示：</p></li>
</ul>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/20171118005825506.png" alt=""/></p>

<p>创建完BytecodeFixTransform后需要把它添加到Android的编译流程中，修改BytecodeFixPlugin的apply()方法，如下所示：</p>

<pre><code class="language-groovy">@Override
void apply(Project project) {
 
    def android = project.extensions.findByType(AppExtension.class)
    def versionName = android.defaultConfig.versionName
 
    android.registerTransform(new BytecodeFixTransform(project, versionName))
}
</code></pre>

<p>现在BytecodeFixTransform已经添加到打包流程中了，如果运行项目会失败的，因为在整个运行流程中上一个Transform的输入进入了BytecodeFixTransform的transfrom()方法中，但该方法没有输出，所以要在transform()方法中做资源的输出，代码如下所示：</p>

<pre><code class="language-groovy">@Override
public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
    if (null == transformInvocation) {
        throw new IllegalArgumentException(&quot;transformInvocation is null !!!&quot;)
    }
    Collection&lt;TransformInput&gt; inputs = transformInvocation.inputs
    if (null == inputs) {
        throw new IllegalArgumentException(&quot;TransformInput is null !!!&quot;)
    }
 
    TransformOutputProvider outputProvider = transformInvocation.outputProvider;
 
    if (null == outputProvider) {
        throw new IllegalArgumentException(&quot;TransformInput is null !!!&quot;)
    }
 
    for (TransformInput input : inputs) {
 
        if (null == input) continue;
 
        // 把项目中的class文件拷贝到指定目录
        for (DirectoryInput directoryInput : input.directoryInputs) {
 
            if (directoryInput) {
 
                if (null != directoryInput.file &amp;&amp; directoryInput.file.exists()) {
                    // directoryInput.file就是我们项目中编译过的class文件
 
                    // 获取指定目录，固定写法
                    File dest = outputProvider.getContentLocation(directoryInput.getName(), directoryInput.getContentTypes(), directoryInput.getScopes(), Format.DIRECTORY);
                    FileUtils.copyDirectory(directoryInput.file, dest);
                }
            }
        }
 
        // 把依赖的第三方Jar文件拷贝到指定目录
        for (JarInput jarInput : input.jarInputs) {
            if (jarInput) {
                if (jarInput.file &amp;&amp; jarInput.file.exists()) {
                    String jarName = jarInput.name;
                    String md5Name = DigestUtils.md5Hex(jarInput.file.absolutePath);
 
                    if (jarName.endsWith(&quot;.jar&quot;)) {
                        jarName = jarName.substring(0, jarName.length() - 4);
                    }
                    // jarInput.file文件就是依赖的一些第三方Jar包，修复第三方的Jar包就是在这里进行处理的
 
                    // 获取指定目录，固定写法
                    File dest = outputProvider.getContentLocation(DigestUtils.md5Hex(jarName + md5Name), jarInput.contentTypes, jarInput.scopes, Format.JAR);
 
                    if (dest) {
                        if (dest.parentFile) {
                            if (!dest.parentFile.exists()) {
                                dest.parentFile.mkdirs();
                            }
                        }
 
                        if (!dest.exists()) {
                            dest.createNewFile();
                        }
 
                        FileUtils.copyFile(jarInput.file, dest);
                    }
                }
            }
        }
    }
}
</code></pre>

<p>在transform()方法添加输出后，项目就可以运行起来了。目前transform()方法仅仅是把输入文件集合拷贝到目的文件夹中，而这些输入文件集合和输出文件路径是通过TransformInput和TransformOutputProvider提供的。我们修改第三方Jar包的时机就是在这里进行的，先把输入进来的第三方Jar包文件做修改，修改之后就直接把修改过的Jar包拷贝进目标文件夹中就行了，实现思路就是这样，很简单，有木有(<em><sup>__^</sup></em>) ……</p>

<h1 id="toc_1">中篇</h1>

<p>在上篇我们主要讲解了如何创建自定义Gradle Plugin以及修复第三方Jar包中的bug的思路。这篇就带领小伙伴们借助Javassist开源库实现对class文件的修改。</p>

<p>上篇中我们讲到了修改第三方Jar包的时机是在BytecodeFixTransform的transform()方法中，也就是在待修改Jar包在被拷贝目标文件夹之前先做修改，修改完成之后我们直接把修改过的Jar包拷贝进目标文件夹而不是原来的Jar包。既然要修改Jar包里的class文件，我们就要知道是哪一个class需要修复，然后还要是class里边的哪一个方法需要修复，还要清楚要修复的内容是什么等等，因此我定义一个BytecodeFixExtension类来表示修复配置，如下所示：</p>

<pre><code class="language-groovy">package com.llew.bytecode.fix.extension
 
public class BytecodeFixExtension {
 
    /**
     * 字节码修复插件是否可用，默认可用
     */
    boolean enable = true
 
    /**
     * 是否开启日志功能，默认开启
     */
    boolean logEnable = true
 
    /**
     * 是否保留修复过的jar文件，默认保留
     */
    boolean keepFixedJarFile = true
 
    /**
     * 时候保留修复过的class文件，默认保留
     */
    boolean keepFixedClassFile = true
 
    /**
     * 构建字节码所依赖的第三方包绝对路径，默认包含了Android.jar文件
     */
    ArrayList&lt;String&gt; dependencies = new ArrayList&lt;String&gt;()
 
    /**
     * 配置文件集合，配置格式：className##methodName(param1,param2...paramN)##injectValue##injectLine
     */
    ArrayList&lt;String&gt; fixConfig = new ArrayList&lt;&gt;();
 
    // 省略了setters and getters 方法
}
</code></pre>

<p>在BytecodeFixExtension中需要注意dependencies和fixConfig的配置。dependencies表示在利用Javassist修复class文件时所依赖的Jar包，例如修复上篇文章中提到的getMobileAPInfo()方法就需要引入ContextCompat类，因此需要添加ContextCompat所在Jar包的绝对路径。fixConfig表示修复信息集合，它的格式是固定的，必须以##做分隔符，格式如下：className##methodName(param1,param2...paramN)##injectValue##injectLine，具体字段说明如下所示：</p>

<ul>
<li><p>className：表示全类名<br/>
    例如：com.tencent.av.sdk.NetworkHelp</p></li>
<li><p>methodName(param1,param2...paramN)：表示方法名及相关参数，参数只写类型且必须以逗号(,)分隔，非基础数据类型要写全路径<br/>
    例如：getAPInfo(android.content.Context)<br/>
    例如：getAPInfo(android.content.Context, int)</p></li>
<li><p>injectValue：表示待插入代码块，注意代码块要有分号(;)，其中:<br/>
    <code>$0表示this；$1表示第一个参数；$2表示第二个参数；以此类推</code><br/>
    例如：<br/>
   <code>$1 = null;System.out.println(&quot;I have hooked this method by BytecodeFixer Plugin !!!&quot;);$1 = null;</code><br/>
   就是表示把第一个参数置空；接着是打印一句日志<br/>
   <strong>【注意：】如果injectValue为{}表示给原有方法添加try-catch操作</strong></p></li>
<li><p>injectLine：表示插在方法中的哪一行，该参数可选，如果省略该参数则默认把injectValue插在方法的最开始处<br/>
    injectLine &gt; 0 插入具体行数<br/>
    injectLine = 0 插入方法最开始处<br/>
    injectLine &lt; 0 替换方法体<br/>
上边讲解了配置文件的规则，接下来就是实现具体的Jar包的修改了，创建BytecodeFixInjector类，该类的职责就是进行Jar包文件的修复，然后把修复后的Jar包返回给调用者。代码如下：</p></li>
</ul>

<pre><code class="language-groovy">package com.llew.bytecode.fix.injector
 
import com.llew.bytecode.fix.extension.BytecodeFixExtension
import com.llew.bytecode.fix.task.BuildJarTask
import com.llew.bytecode.fix.utils.FileUtils
import com.llew.bytecode.fix.utils.Logger
import com.llew.bytecode.fix.utils.TextUtil
import javassist.ClassPool
import javassist.CtClass
import javassist.CtMethod
import org.gradle.api.Project
 
import java.util.jar.JarFile
import java.util.zip.ZipFile
 
public class BytecodeFixInjector {
 
    private static final String INJECTOR  = &quot;injector&quot;
    private static final String JAVA      = &quot;.java&quot;
    private static final String CLASS     = &quot;.class&quot;
    private static final String JAR       = &quot;.jar&quot;
 
    private static ClassPool sClassPool
    private static BytecodeFixInjector sInjector
 
    private Project mProject
    private String mVersionName
    private BytecodeFixExtension mExtension
 
    private BytecodeFixInjector(Project project, String versionName, BytecodeFixExtension extension) {
        this.mProject = project
        this.mVersionName = versionName
        this.mExtension = extension
        appendClassPath()
    }
 
    public static void init(Project project, String versionName, BytecodeFixExtension extension) {
        sClassPool = ClassPool.default
        sInjector = new BytecodeFixInjector(project, versionName, extension)
    }
 
    public static BytecodeFixInjector getInjector() {
        if (null == sInjector) {
            throw new IllegalAccessException(&quot;init() hasn&#39;t bean called !!!&quot;)
        }
        return sInjector
    }
 
    public synchronized File inject(File jar) {
        File destFile = null
 
        if (null == mExtension) {
            Logger.e(&quot;can&#39;t find bytecodeFixConfig in your app build.gradle !!!&quot;)
            return destFile
        }
 
        if (null == jar) {
            Logger.e(&quot;jar File is null before injecting !!!&quot;)
            return destFile
        }
 
        if (!jar.exists()) {
            Logger.e(jar.name + &quot; not exits !!!&quot;)
            return destFile
        }
 
        try {
            ZipFile zipFile = new ZipFile(jar)
            zipFile.close()
            zipFile = null
        } catch (Exception e) {
            Logger.e(jar.name + &quot; not a valid jar file !!!&quot;)
            return destFile
        }
 
        def jarName = jar.name.substring(0, jar.name.length() - JAR.length())
        def baseDir = new StringBuilder().append(mProject.projectDir.absolutePath)
                .append(File.separator).append(INJECTOR)
                .append(File.separator).append(mVersionName)
                .append(File.separator).append(jarName).toString()
 
        File rootFile = new File(baseDir)
        FileUtils.clearFile(rootFile)
        rootFile.mkdirs()
 
        File unzipDir = new File(rootFile, &quot;classes&quot;)
        File jarDir   = new File(rootFile, &quot;jar&quot;)
 
        JarFile jarFile = new JarFile(jar)
        mExtension.fixConfig.each { config -&gt;
            if (!TextUtil.isEmpty(config.trim())) {
                // com.tencent.av.sdk.NetworkHelp##getAPInfo(android.content.Context)##if(Boolean.TRUE.booleanValue()){$1 = null;System.out.println(&quot;i have hooked this method !!!&quot;);}##0
                def configs = config.trim().split(&quot;##&quot;)
                if (null != configs &amp;&amp; configs.length &gt; 0) {
                    if (configs.length &lt; 3) {
                        throw new IllegalArgumentException(&quot;参数配置有问题&quot;)
                    }
 
                    def className   = configs[0].trim()
                    def methodName  = configs[1].trim()
                    def injectValue = configs[2].trim()
                    def injectLine  = 0
                    if (4 == configs.length) {
                        try {
                            injectLine  = Integer.parseInt(configs[3])
                        } catch (Exception e) {
                            throw new IllegalArgumentException(&quot;行数配置有问题&quot;)
                        }
                    }
 
                    if (TextUtil.isEmpty(className)) {
                        Logger.e(&quot;className invalid !!!&quot;)
                        return
                    }
 
                    if (TextUtil.isEmpty(methodName)) {
                        Logger.e(&quot;methodName invalid !!!&quot;)
                        return
                    }
 
                    if (TextUtil.isEmpty(injectValue)) {
                        Logger.e(&quot;inject value invalid !!!&quot;)
                        return
                    }
 
                    def methodParams = new ArrayList&lt;String&gt;()
 
                    if (methodName.contains(&quot;(&quot;) &amp;&amp; methodName.contains(&quot;)&quot;)) {
                        def tempMethodName = methodName
                        methodName = tempMethodName.substring(0, tempMethodName.indexOf(&quot;(&quot;)).trim()
                        def params = tempMethodName.substring(tempMethodName.indexOf(&quot;(&quot;) + 1, tempMethodName.indexOf(&quot;)&quot;)).trim()
                        if (!TextUtil.isEmpty(params)) {
                            if (params.contains(&quot;,&quot;)) {
                                params = params.split(&quot;,&quot;)
                                if (null != params &amp;&amp; params.length &gt; 0) {
                                    params.each { p -&gt;
                                        methodParams.add(p.trim())
                                    }
                                }
                            } else {
                                methodParams.add(params)
                            }
                        }
                    }
 
                    if (className.endsWith(JAVA)) {
                        className = className.substring(0, className.length() - JAVA.length()) + CLASS
                    }
 
                    if (!className.endsWith(CLASS)) {
                        className += CLASS
                    }
 
                    def contain = FileUtils.containsClass(jarFile, className)
 
                    if (contain) {
                        // 1、判断是否进行过解压缩操作
                        if (!FileUtils.hasFiles(unzipDir)) {
                            FileUtils.unzipJarFile(jarFile, unzipDir)
                        }
 
                        // 2、开始注入文件，需要注意的是，appendClassPath后边跟的根目录，没有后缀，className后完整类路径，也没有后缀
                        sClassPool.appendClassPath(unzipDir.absolutePath)
 
                        // 3、开始注入，去除.class后缀
                        if (className.endsWith(CLASS)) {
                            className = className.substring(0, className.length() - CLASS.length())
                        }
 
                        CtClass ctClass = sClassPool.getCtClass(className)
 
                        if (!ctClass.isInterface()) {
                            CtMethod ctMethod
                            if (methodParams.isEmpty()) {
                                ctMethod = ctClass.getDeclaredMethod(methodName)
                            } else {
                                CtClass[] params = new CtClass[methodParams.size()]
                                for (int i = 0; i &lt; methodParams.size(); i++) {
                                    String param = methodParams.get(i)
                                    params[i] = sClassPool.getCtClass(param)
                                }
                                ctMethod = ctClass.getDeclaredMethod(methodName, params)
                            }
 
                            if (injectLine &gt; 0) {
                                ctMethod.insertAt(injectLine, injectValue)
                            } else if (injectLine == 0) {
                                ctMethod.insertBefore(injectValue)
                            } else {
                                if (!injectValue.startsWith(&quot;{&quot;)) {
                                    injectValue = &quot;{&quot; + injectValue
                                }
                                if (!injectValue.endsWith(&quot;}&quot;)) {
                                    injectValue = injectValue + &quot;}&quot;
                                }
                                ctMethod.setBody(injectValue)
                            }
 
                            ctClass.writeFile(unzipDir.absolutePath)
                            ctClass.detach()
                        } else {
                            Logger.e(className + &quot; is interface and can&#39;t inject code ！！！&quot;)
                        }
                    }
                }
            }
        }
 
        // 4、循环体结束，判断classes文件夹下是否有文件
        if (FileUtils.hasFiles(unzipDir)) {
            BuildJarTask buildJarTask = mProject.tasks.create(&quot;BytecodeFixBuildJarTask&quot;, BuildJarTask)
            buildJarTask.baseName = jarName
            buildJarTask.from(unzipDir.absolutePath)
            buildJarTask.doLast {
                // 进行文件的拷贝
                def stringBuilder = new StringBuilder().append(mProject.projectDir.absolutePath)
                        .append(File.separator).append(&quot;build&quot;)
                        .append(File.separator).append(&quot;libs&quot;)
                        .append(File.separator).append(jar.name).toString()
 
                if (!jarDir.exists()) {
                    jarDir.mkdirs()
                }
 
                destFile = new File(jarDir, jar.name)
                FileUtils.clearFile(destFile)
                destFile.createNewFile()
 
                File srcFile = new File(stringBuilder)
                com.android.utils.FileUtils.copyFile(srcFile, destFile)
                FileUtils.clearFile(srcFile)
 
                if (null != mExtension &amp;&amp; !mExtension.keepFixedClassFile) {
                    FileUtils.clearFile(unzipDir)
                }
            }
            // FIXME buildJarTask sometimes has bug
            // buildJarTask.execute()
 
            destFile = new File(jarDir, jar.name)
            FileUtils.clearFile(destFile)
            FileUtils.zipJarFile(unzipDir, destFile)
 
            if (null != mExtension &amp;&amp; !mExtension.keepFixedClassFile) {
                FileUtils.clearFile(unzipDir)
            }
        } else {
            FileUtils.clearFile(rootFile)
        }
 
        jarFile.close()
 
        return destFile
    }
 
    private void appendClassPath() {
        if (null == mProject) return
        def androidJar = new StringBuffer().append(mProject.android.getSdkDirectory())
                .append(File.separator).append(&quot;platforms&quot;)
                .append(File.separator).append(mProject.android.compileSdkVersion)
                .append(File.separator).append(&quot;android.jar&quot;).toString()
 
        File file = new File(androidJar);
        if (!file.exists()) {
            androidJar = new StringBuffer().append(mProject.rootDir.absolutePath)
                    .append(File.separator).append(&quot;local.properties&quot;).toString()
 
            Properties properties = new Properties()
            properties.load(new File(androidJar).newDataInputStream())
 
            def sdkDir = properties.getProperty(&quot;sdk.dir&quot;)
 
            androidJar = new StringBuffer().append(sdkDir)
                    .append(File.separator).append(&quot;platforms&quot;)
                    .append(File.separator).append(mProject.android.compileSdkVersion)
                    .append(File.separator).append(&quot;android.jar&quot;).toString()
 
            file = new File(androidJar)
        }
 
        if (file.exists()) {
            sClassPool.appendClassPath(androidJar);
        } else {
            Logger.e(&quot;couldn&#39;t find android.jar file !!!&quot;)
        }
 
        if (null != mExtension &amp;&amp; null != mExtension.dependencies) {
            mExtension.dependencies.each { dependence -&gt;
                sClassPool.appendClassPath(dependence)
            }
        }
    }
}
</code></pre>

<p>以上就是BytecodeFixInjector的全部代码了，在BytecodeFixInjector中我们定义了静态变量sClassPool和sInjector，并在创建该对象的时候初始化了相关的非静态属性值，并调用appendClassPath()方法把默认的android.jar文件以及BytecodeFixExtension中配置的依赖包添加到sClassPool中去，这样可以防止在进行class文件操作由于找不到引用而发生错误的问题。BytecodeFixInjector的核心代码是inject()方法，该方法接收原始的Jar包，如果该原始Jar包需要做修复，则进行修复并把修复后的Jar包返回给调用者；如果该原始Jar包不需要做修改则返回一个null值，null就表示告诉调用者原始Jar包不需要做修改。</p>

<p>BytecodeFixInjector定义完之后在BytecodeFixTransform的transfrom()方法做接入，代码如下：</p>

<pre><code class="language-groovy">public class BytecodeFixTransform extends Transform {
 
    private static final String DEFAULT_NAME = &quot;BytecodeFixTransform&quot;
 
    private BytecodeFixExtension mExtension;
 
    BytecodeFixTransform(Project project, String versionName, BytecodeFixExtension extension) {
        this.mExtension = extension
        Logger.enable = extension.logEnable
        BytecodeFixInjector.init(project, versionName, mExtension)
    }
 
    @Override
    public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
        
        // 省略相关代码...
 
        for (TransformInput input : inputs) {
 
            if (null == input) continue;
 
            for (DirectoryInput directoryInput : input.directoryInputs) {
 
                if (directoryInput) {
 
                    if (null != directoryInput.file &amp;&amp; directoryInput.file.exists()) {
 
                        // ClassInjector.injector.inject(directoryInput.file.absolutePath, mPackageName.replaceAll(&quot;\\.&quot;, File.separator));
 
                        File dest = outputProvider.getContentLocation(directoryInput.getName(), directoryInput.getContentTypes(), directoryInput.getScopes(), Format.DIRECTORY);
                        FileUtils.copyDirectory(directoryInput.file, dest);
                    }
                }
            }
 
            for (JarInput jarInput : input.jarInputs) {
                if (jarInput) {
                    if (jarInput.file &amp;&amp; jarInput.file.exists()) {
                        String jarName = jarInput.name;
                        String md5Name = DigestUtils.md5Hex(jarInput.file.absolutePath);
 
                        if (jarName.endsWith(&quot;.jar&quot;)) {
                            jarName = jarName.substring(0, jarName.length() - 4);
                        }
 
                        // 在这里jar文件进行动态修复，这里是重点
                        File injectedJarFile = null
                        if (null != mExtension &amp;&amp; mExtension.enable) {
                            injectedJarFile = BytecodeFixInjector.injector.inject(jarInput.file)
                        }
 
                        File dest = outputProvider.getContentLocation(DigestUtils.md5Hex(jarName + md5Name), jarInput.contentTypes, jarInput.scopes, Format.JAR);
 
                        if (dest) {
                            if (dest.parentFile) {
                                if (!dest.parentFile.exists()) {
                                    dest.parentFile.mkdirs();
                                }
                            }
 
                            if (!dest.exists()) {
                                dest.createNewFile();
                            }
 
                            // 校验injectedJarFile是否做过修改，如果做过修改则直接把injectedJarFile拷贝到目的文件夹中
                            // 然后根据mExtension的配置是否保留修复过的injectedJarFile文件
                            if (null != injectedJarFile &amp;&amp; injectedJarFile.exists()) {
                                FileUtils.copyFile(injectedJarFile, dest)
                                Logger.e(jarInput.file.name + &quot; has successful hooked !!!&quot;)
                                if (null != mExtension &amp;&amp; !mExtension.keepFixedJarFile) {
                                    injectedJarFile.delete()
                                }
                            } else {
                                FileUtils.copyFile(jarInput.file, dest)
                            }
                        }
                    }
                }
            }
        }
    }
}
</code></pre>

<p>到这里修复第三方Jar包的核心逻辑已经完成了，具体细节就不贴出了，我把该插件起名为 BytecodeFixer并开源到了 GitHub上然后又上传到了Jcenter上，GitHub地址： <a href="https://github.com/llew2011/BytecodeFixer">https://github.com/llew2011/BytecodeFixer</a> </p>

<p>该插件使用如下：</p>

<p>1、在工程 根目录的build.gradle文件中添加如下配置：</p>

<pre><code class="language-groovy"> dependencies {
    classpath &#39;com.android.tools.build:gradle:2.3.3&#39;
    classpath &#39;com.jakewharton:butterknife-gradle-plugin:8.6.0&#39;
 
    // 添加如下配置
    classpath &#39;com.llew.bytecode.fix.gradle:BytecodeFixer:1.0.2&#39;
}
</code></pre>

<p>2、在主工程的build.gradle文件 末尾添加如下配置：</p>

<pre><code class="language-groovy">apply plugin: &#39;com.llew.bytecode.fix&#39;
 
bytecodeFixConfig {
 
    enable true
 
    logEnable = true
 
    keepFixedJarFile = true
 
    keepFixedClassFile = true
 
    dependencies = []
 
    fixConfig = [
            &#39;com.tencent.av.sdk.NetworkHelp##getAPInfo(android.content.Context)##$1 = null;System.out.println(&quot;I have hooked this method by BytecodeFixer !!!&quot;);##0&#39;,
            &#39;com.tencent.av.sdk.NetworkHelp##getMobileAPInfo(android.content.Context,int)##$1 = null;System.out.println(&quot;I have hooked this method by BytecodeFixer !!!&quot;);return new com.tencent.av.sdk.NetworkHelp.APInfo();##-1&#39;,
    ]
}
</code></pre>

<p>配置完成之后，运行项目，这时候会在 主工程的目录下生成修复过的class文件，如下所示：</p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/20171117183926435.png" alt=""/></p>

<p>好了，运行项目后，通过bytecodeFixConfig的配置，目标Jar文件就会被自动修复，是不是很方便，顿时这个世界是那么的美好，从此以后不管用户授予没有授予相关权限，都可以让用户愉快的玩耍我们APP了，并且做到了一切第三方的Jar文件都在我们的掌控中，看哪一个方法不顺眼就可以使用 BytecodeFixer插件做修复，是不是很爽？因此在Java的世界里，如果你精通反射，代理，再加上Javassist利器，你可以做很多事情…… </p>

<h1 id="toc_2">下篇</h1>

<p>前两篇主要讲解了如何自定义Gradle Plugin，然后利用自定义的Gradle Plugin插件来修复项目中引用的第三方Jar包中的bug的方法，其核心就是利用开源库Javassist修复第三方Jar包中的class文件，然后在项目打包的时候把修复过的Jar包打包进项目中从而达到修复的目的。<br/>
这篇我们就从源码的角度深入理解一下Javassist库是如何修复class文件的(<em><sup>__^</sup></em>) ……</p>

<p>阅读开源代码，一般都是从使用开始，记得在上篇文章中我们是如何使用Javassist库的么？首先是初始化了ClassPool对象sClassPool，代码如下：</p>

<pre><code class="language-java">public static void init(Project project, String versionName, BytecodeFixExtension extension) {
    sClassPool = ClassPool.default
    sInjector = new BytecodeFixInjector(project, versionName, extension)
}
</code></pre>

<p>在BytecodeFixInjector的init()方法中通过ClassPool的静态方法getDefault()返回一个ClassPool对象然后赋值给了sClassPool，ClassPool是做什么工作的？它的职责是什么？根据名字像是一个对象池，既然是对象池，应该像数据库连接池一样能提供对象的哈，这是我第一次接触它的时候猜测的，我们看一下ClassPool的说明：</p>

<blockquote>
<p>A container of CtClass objects. A CtClass object must be obtained from this object. If get() is called on this object, it searches various sources represented by ClassPath to find a class file and then it creates a CtClass object representing that class file. The created object is returned to the caller.</p>
</blockquote>

<p>【译】ClassPool是CtClass的容器，每一个CtClass对象都必须从ClassPool中获取。如果调用了ClassPool的get()方法，那么ClassPool就会搜索由ClassPath指定的不同资源去找到一个class文件然后ClassPool就会创建一个CtClass对象，该对象就代表着那个.class文件。最后ClassPool创建的CtClass对象会返回给调用者。</p>

<blockquote>
<p>ClassPool objects hold all the CtClasses that have been created so that the consistency among modified classes can be guaranteed. Thus if a large number of CtClasses are processed, the ClassPool will consume a huge amount of memory. To avoid this, a ClassPool object should be recreated, for example, every hundred classes processed. Note that getDefault() is a singleton factory. Otherwise, detach() in CtClass should be used to avoid huge memory consumption.</p>
</blockquote>

<p>【译】ClassPool持有所有创建的CtClass对象，因此修改类的话，它们之间的一致性可以得到保证。因此，如果处理大量的CtClass类，ClassPool将要消耗大量的内存，为了避免这种情况，应该重新创建ClassPool对象，例如，每次都要处理成千上百的class类。注意，getDefault()方法是一个单例模式的工厂方法，因此，应该调用detach()方法来避免大量的内存消耗。</p>

<blockquote>
<p>ClassPools can make a parent-child hierarchy as java.lang.ClassLoaders. If a ClassPool has a parent pool, get() first asks the parent pool to find a class file. Only if the parent could not find the class file, get() searches the ClassPaths of the child ClassPool. This search order is reversed if ClassPath.childFirstLookup is true.</p>
</blockquote>

<p>【译】ClassPool支持像java.lang.ClassLoaders那样的父子层次结构，如果ClassPool有个父类ClassPool，当调用ClassPool的get()方法时，ClassPool会首先请求父类ClassPool查询相应的class文件，只有在父类ClassPool找不到的情况下，才会调用自身的get()方法查询</p>

<p>根据ClassPool的说明，我们可以得出一下几点重要信息：</p>

<ul>
<li><p>CtClass代表一个.class文件，它必须由ClassPool创建</p></li>
<li><p>ClassPool可能消耗较大内存，应当及时调用detach()方法</p></li>
<li><p>ClassPool支持像ClassLoader一样的双亲委派模型</p></li>
</ul>

<p>理解了ClassPool之后，我们看看ClassPool的getDefault()方法，代码如下：</p>

<pre><code class="language-java">public static synchronized ClassPool getDefault() {
    if (defaultPool == null) {
        defaultPool = new ClassPool(null);
        defaultPool.appendSystemPath();
    }
 
    return defaultPool;
}
 
public ClassPool(ClassPool parent) {
    this.classes = new Hashtable(INIT_HASH_SIZE);
    this.source = new ClassPoolTail();
    this.parent = parent;
    if (parent == null) {
        CtClass[] pt = CtClass.primitiveTypes;
        for (int i = 0; i &lt; pt.length; ++i)
            classes.put(pt[i].getName(), pt[i]);
    }
 
    this.cflow = null;
    this.compressCount = 0;
    clearImportedPackages();
}
</code></pre>

<p>getDefault()方法首先判断defaultPool是否为null，如果为null就创建，在创建的ClassPool对象的时候给其构造方法传递一个null值进去(传递null值表示当前ClassPool是根节点ClassPool)。在ClassPool的构造方法内部初始化了缓存CtClass对象的classes成员变量和ClassPoolTail类型的成员变量source(ClassPoolTail模拟了链表的数据结构，它存储了一个链式顺序的ClassPath)，最后调用source的appendSystemPath()方法，代码如下：</p>

<pre><code class="language-java">public ClassPath appendSystemPath() {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return appendClassPath(new LoaderClassPath(cl));
}
</code></pre>

<p>ClassPoolTail的appendSystemPath()方法中先获取当前线程的ClassLoader对象，然后根据当前线程的ClassLoader对象创建了一个LoaderClassPath对象并传递进了重载方法appendClassPath()，代码如下：</p>

<pre><code class="language-java">public synchronized ClassPath appendClassPath(ClassPath cp) {
    ClassPathList tail = new ClassPathList(cp, null);
    ClassPathList list = pathList;
    if (list == null)
        pathList = tail;
    else {
        while (list.next != null)
            list = list.next;
 
        list.next = tail;
    }
 
    return cp;
}
</code></pre>

<p>appendClassPath()方法就是把传递进来ClassPath存储在链表的最后，根据代码调用顺序来看，刚刚创建的LoaderClassPath就是ClassPoolTail中ClassPath链表的根节点了，而LoaderClassPath的ClassLoader又是当前线程的ClassLoader，熟悉JVM ClassLoader的结构顺序应该清楚，LoaderClassPath包含了当前系统环境变量指定的ClassPath，所以在使用ClassPool的时候默认包含了环境变量配置的那些SDK包。以上就是ClassPool的主要流程，我们接着看一下CtClass的使用，如下所示：</p>

<p>CtClass实例只能通过ClassPool获取，ClassPool提供了系列的方法来返回CtClass实例，这些方法最终都是调用get0()方法，代码如下：</p>

<pre><code class="language-java">protected synchronized CtClass get0(String classname, boolean useCache) throws NotFoundException {
    CtClass clazz = null;
    if (useCache) {
        clazz = getCached(classname);
        if (clazz != null)
            return clazz;
    }
 
    if (!childFirstLookup &amp;&amp; parent != null) {// 默认情况下parent为null
        clazz = parent.get0(classname, useCache);
        if (clazz != null)
            return clazz;
    }
 
    clazz = createCtClass(classname, useCache);
    if (clazz != null) {
        // clazz.getName() != classname if classname is &quot;[L&lt;name&gt;;&quot;.
        if (useCache)
            cacheCtClass(clazz.getName(), clazz, false);// 加入缓存
 
        return clazz;
    }
 
    if (childFirstLookup &amp;&amp; parent != null)// 默认情况下parent为null
        clazz = parent.get0(classname, useCache);
 
    return clazz;
}
</code></pre>

<p>get0()方法中首先从缓存中查找，如果缓存中存在就直接返回缓存中的CtClass对象，否则调用createCtClass()方法创建CtClass对象然后根据参数useCache判断是否缓存新建的CtClass对象，createCtClass()方法代码如下：</p>

<pre><code class="language-java">protected CtClass createCtClass(String classname, boolean useCache) {
    // accept &quot;[L&lt;class name&gt;;&quot; as a class name. 【classname可以死[L&lt;class name&gt;;的参数，不过不建议传递这种参数】
    if (classname.charAt(0) == &#39;[&#39;)
        classname = Descriptor.toClassName(classname);
 
    if (classname.endsWith(&quot;[]&quot;)) {
        String base = classname.substring(0, classname.indexOf(&#39;[&#39;));
        if ((!useCache || getCached(base) == null) &amp;&amp; find(base) == null)
            return null;
        else
            return new CtArray(classname, this);
    } else
        if (find(classname) == null)// 调用find()方法来遍历ClassPathList链表从而查询对应的class文件
            return null;
        else
            return new CtClassType(classname, this);
}
</code></pre>

<p>createCtClass()方法根据条件判断最后通过find()方法做查找，如果查找到了对应的classname就根据classname创建一个CtClassType并返回(由此可见CtClassType一定是CtClass实现类，之后CtClass的行为也就是CtClassType的行为了)。创建了CtClass后就可以进行一系列的操作了，比如添加属性，添加方法，修改方法等。我们就拿修改方法举例子。对方法的相关操作必须使用CtMethod对象，它需要从CtClass中获取，代码如下：</p>

<pre><code class="language-java">CtMethod ctMethod = ctClass.getDeclaredMethod(methodName)
</code></pre>

<p>通过调用ctClass的getDeclaredMethod(methodname)方法实际上执行的的是CtClassType的getDeclaredMethod(methodname)方法，我们直接看CtClassType中的getDeclaredMethod()方法实现，代码如下：</p>

<pre><code class="language-java">public CtMethod getDeclaredMethod(String name) throws NotFoundException {
    CtMember.Cache memCache = getMembers();
    CtMember mth = memCache.methodHead();
    CtMember mthTail = memCache.lastMethod();
    while (mth != mthTail) {
        mth = mth.next();
        if (mth.getName().equals(name))
            return (CtMethod)mth;
    }
 
    throw new NotFoundException(name + &quot;(..) is not found in &quot; + getName());
}
</code></pre>

<p>getDeclaredMethod()方法中调用了返回Cache类型的getMembers()方法，getMembers()方法主要功能是解析当前class的属性和方法并做缓存，然后遍历当前class的所有方法，当遍历到的CtMethod的name和传递进来的name相等就返回该CtMethod，如果匹配不到就抛异常。 </p>

<p>CtMethod提供了一系列的对方法的操作方法，比如inserBifore()，intsertAfter()，setBody()等众多方法，我们就看setBody()方法(其它操作流程都是类似的)，该方法表示重置方法体，代码如下：</p>

<pre><code class="language-java">public void setBody(String src) throws CannotCompileException {
    setBody(src, null, null);
}
 
public void setBody(String src, String delegateObj, String delegateMethod) throws CannotCompileException {
    CtClass cc = declaringClass;
    cc.checkModify();
    try {
        Javac jv = new Javac(cc);
        if (delegateMethod != null) {
            jv.recordProceed(delegateObj, delegateMethod);
        }
 
        Bytecode b = jv.compileBody(this, src);
        methodInfo.setCodeAttribute(b.toCodeAttribute());
        methodInfo.setAccessFlags(methodInfo.getAccessFlags() &amp; ~AccessFlag.ABSTRACT);
        methodInfo.rebuildStackMapIf6(cc.getClassPool(), cc.getClassFile2());
        declaringClass.rebuildClassFile();
    } catch (CompileError e) {
        throw new CannotCompileException(e);
    } catch (BadBytecode e) {
        throw new CannotCompileException(e);
    }
}
</code></pre>

<p>CtMethod的setBody()有两个重载方法，最终都是调用三个参数的的setBody()方法，在setBody()方法中根据CtClass新建了一个Javac对象(javassist包含了一个小的Java编译器系统，其中Javac就是模拟的JDK中的javac命令，它用来把Java代码编译成二进制的class文件)。接着调用Javac的compileBody()方法把传递进来的src编译成二进制字节码，由于篇幅原因以具体的Javac的编译细节就不再这里展开叙述了，如果有小伙伴想详细的了解JVM指令，这里推荐小伙伴们看一下《Java虚拟机规范》和《深入理解Java虚拟机》这两本书，书中讲解的很详细，强烈建议阅读一下。</p>

<p>通过CtMethod修改了CtClass的方法之后，如果想持久化存储修复后的class，可以调用CtClass的writeFile()方法，writeFile()源码如下：</p>

<pre><code class="language-java">public void writeFile() throws NotFoundException, IOException, CannotCompileException {
    writeFile(&quot;.&quot;);
}
 
public void writeFile(String directoryName) throws CannotCompileException, IOException {
    DataOutputStream out = makeFileOutput(directoryName);
    try {
        toBytecode(out);
    } finally {
        out.close();
    }
}
</code></pre>

<p>CtClass的writeFile()方法同样有两个重载方法，无参数的writeFile()方法表示把CtClass直接存储在当前目录下的clsass文件中，带有参数的writeFile(String dir)表示可以把修改后的CtClass写入指定目录中。</p>

<p>以上就是CtClass的一般操作流程，为了方便查看CtClass的流程，下面我画了一张javassist库的部分结构图，如下所示：</p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/20171129235554532.jpeg" alt=""/></p>

<p>关于使用Javassist库修改class文件的流程基本上就是这些了，该库的核心就是根据JVM规范自定义了一套编译器把我们的传递进来的字符串编译成JVM可识别和执行的二进制字节码，如果想要详细的了解JVM请自行查阅相关文档。</p>

<p>这里再补充一下使用 BytecodeFixer插件的注意事项：</p>

<ul>
<li><p>在对CtClass的操作中除了基本类型外，其他任何类型都要使用类的全路径</p></li>
<li><p>操作方法时<strong>$0</strong>表示this关键字，<strong>$1</strong>表示第一个参数，<strong>$2</strong>表示第二个参数，以此类推</p></li>
<li><p>为了保证Mac和Windows系统下路径的兼容性，一定要使用File.separator进行路径的拼接</p></li>
<li><p>如果待修复的Jar包中需要引用主项目的类，可以在dependencies配置项依赖添加getAppClassesDir()方法，如下所示：</p></li>
</ul>

<pre><code class="language-groovy">apply plugin: &#39;com.llew.bytecode.fix&#39;

bytecodeFixConfig {

    enable = true

    logEnable = true

    keepFixedJarFile = true

    keepFixedClassFile = true

    dependencies = [
            getAppClassesDir()
    ]

    fixConfig = [
            &#39;com.tencent.av.sdk.NetworkHelp##getMobileAPInfo(android.content.Context,int)##if(android.content.pm.PackageManager.PERMISSION_GRANTED != $1.checkPermission(android.Manifest.permission.READ_PHONE_STATE, android.os.Process.myPid(), android.os.Process.myUid())){return new com.tencent.av.sdk.NetworkHelp.APInfo();}##0&#39;,
            &#39;com.umeng.qq.tencent.h##a(android.app.Activity,android.content.Intent,int)##try{$2.putExtra(&quot;key_request_code&quot;, $3);$1.startActivityForResult($0.a($1, $2), $3);} catch(Exception e) {e.printStackTrace();};##-1&#39;,
            &#39;com.umeng.qq.tencent.h##a(android.app.Activity,int,android.content.Intent,java.lang.Boolean)##try{android.content.Intent var5 = new android.content.Intent($1.getApplicationContext(), com.umeng.qq.tencent.AssistActivity.class);if($4.booleanValue()){var5.putExtra(&quot;is_qq_mobile_share&quot;, true);}var5.putExtra(&quot;openSDK_LOG.AssistActivity.ExtraIntent&quot;, $3);$1.startActivityForResult(var5, $2);}catch(Exception e){e.printStackTrace();};##-1&#39;
    ]
}

String getAppClassesDir() {

    android.applicationVariants.all { variant -&gt;

        def variantOutput = variant.outputs.first()
        def variantName = variant.name
        def variantData = variant.variantData
        def buildType   = variant.buildType.name

        def str = new StringBuffer().append(project.rootDir.absolutePath)
                .append(File.separator).append(&quot;app&quot;)
                .append(File.separator).append(&quot;build&quot;)
                .append(File.separator).append(&quot;intermediates&quot;)
                .append(File.separator).append(&quot;classes&quot;)
                .append(File.separator).append(variantName.subSequence(0, buildType.length()))
                .append(File.separator).append(buildType)
                .append(File.separator).toString()
        return str
    }

    return new StringBuffer().append(project.rootDir.absolutePath)
        .append(File.separator).append(&quot;app&quot;)
        .append(File.separator).append(&quot;build&quot;)
        .append(File.separator).append(&quot;intermediates&quot;)
        .append(File.separator).append(&quot;classes&quot;)
        .append(File.separator).append(&quot;dev&quot;)
        .append(File.separator).append(&quot;debug&quot;)
        .append(File.separator).toString()
}
</code></pre>


</div>

<br /><br />
<hr />

<div class="content-nav">
    <div class="large-6 columns">
        <div class="text-left" style="padding:15px 0px;">
            
            <a href="16280610391708.html" title="Previous Post: Gradle 自定义Plugin插件之上传APK到蒲公英">&laquo; Gradle 自定义Plugin插件之上传APK到蒲公英</a> 
        </div>
    </div>
    <div class="large-6 columns">
        <div class="text-right" style="padding:15px 0px;">
            
            <a href="16280610391616.html" title="Next Post: 如何使用Android Studio开发Gradle插件">如何使用Android Studio开发Gradle插件 &raquo;</a> 
        </div>
    </div>
</div>

<div class="content_share">
    <div style="padding:0px 0.93em;" class="share-comments">
        
    </div>
</div>
<script type="text/javascript">
    $(function() {
        var currentURL = '16280610391664.html';
        $('#side-nav a').each(function() {
            if ($(this).attr('href') == currentURL) {
                $(this).parent().addClass('active');
            }
        });
    });
</script>  </div>
</div>


<div class="page-bottom">
    <div class="copyright">
        <a href="mailto:888api@sina.com">郝彬彬</a> &copy; 
    </div>
    <div class="copyright text-right">
        <a href="#main-content">TOP</a>
    </div>
</div>

</div>




  














<style type="text/css">
    figure {
        margin: 0.4em 0;
        padding: 0;
    }
    
    figcaption {
        text-align: center;
    }
    /* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
    /**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */
    
    code[class*="language-"],
    pre[class*="language-"] {
        color: black;
        background: none;
        text-shadow: 0 1px white;
        font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
        text-align: left;
        white-space: pre;
        word-spacing: normal;
        word-break: normal;
        word-wrap: normal;
        line-height: 1.5;
        -moz-tab-size: 4;
        -o-tab-size: 4;
        tab-size: 4;
        -webkit-hyphens: none;
        -moz-hyphens: none;
        -ms-hyphens: none;
        hyphens: none;
    }
    
    pre[class*="language-"]::-moz-selection,
    pre[class*="language-"] ::-moz-selection,
    code[class*="language-"]::-moz-selection,
    code[class*="language-"] ::-moz-selection {
        text-shadow: none;
        background: #b3d4fc;
    }
    
    pre[class*="language-"]::selection,
    pre[class*="language-"] ::selection,
    code[class*="language-"]::selection,
    code[class*="language-"] ::selection {
        text-shadow: none;
        background: #b3d4fc;
    }
    
    @media print {
        code[class*="language-"],
        pre[class*="language-"] {
            text-shadow: none;
        }
    }
    /* Code blocks */
    
    pre[class*="language-"] {
        padding: 1em;
        margin: .5em 0;
        overflow: auto;
    }
    
     :not(pre)>code[class*="language-"],
    pre[class*="language-"] {
        background: #F7F7F7;
    }
    /* Inline code */
    
     :not(pre)>code[class*="language-"] {
        padding: .1em;
        border-radius: .3em;
        white-space: normal;
    }
    
    .token.comment,
    .token.prolog,
    .token.doctype,
    .token.cdata {
        color: slategray;
    }
    
    .token.punctuation {
        color: #999;
    }
    
    .namespace {
        opacity: .7;
    }
    
    .token.property,
    .token.tag,
    .token.boolean,
    .token.number,
    .token.constant,
    .token.symbol,
    .token.deleted {
        color: #905;
    }
    
    .token.selector,
    .token.attr-name,
    .token.string,
    .token.char,
    .token.builtin,
    .token.inserted {
        color: #690;
    }
    
    .token.operator,
    .token.entity,
    .token.url,
    .language-css .token.string,
    .style .token.string {
        color: #9a6e3a;
        background: hsla(0, 0%, 100%, .5);
    }
    
    .token.atrule,
    .token.attr-value,
    .token.keyword {
        color: #07a;
    }
    
    .token.function,
    .token.class-name {
        color: #DD4A68;
    }
    
    .token.regex,
    .token.important,
    .token.variable {
        color: #e90;
    }
    
    .token.important,
    .token.bold {
        font-weight: bold;
    }
    
    .token.italic {
        font-style: italic;
    }
    
    .token.entity {
        cursor: help;
    }
    
    pre[class*="language-"].line-numbers {
        position: relative;
        padding-left: 3.8em;
        counter-reset: linenumber;
    }
    
    pre[class*="language-"].line-numbers>code {
        position: relative;
        white-space: inherit;
    }
    
    .line-numbers .line-numbers-rows {
        position: absolute;
        pointer-events: none;
        top: 0;
        font-size: 100%;
        left: -3.8em;
        width: 3em;
        /* works for line-numbers below 1000 lines */
        letter-spacing: -1px;
        border-right: 1px solid #999;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    .line-numbers-rows>span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }
    
    .line-numbers-rows>span:before {
        content: counter(linenumber);
        color: #999;
        display: block;
        padding-right: 0.8em;
        text-align: right;
    }
</style>

<script src="asset/js/foundation.min.js"></script>
<script src="asset/js/foundation/foundation.offcanvas.js"></script>
<script>
    $(document).foundation();
</script>
<script src="asset/js/watermark.js"></script>

</body>

</html>