<!doctype html>
<html class="no-js" lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
        烂笔头
    </title>
    <meta name="description" content="">
    <link href="atom.xml" rel="alternate" title="烂笔头" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>
        hljs.initHighlightingOnLoad();
    </script>

</head>

<body class="antialiased hide-extras"></body>

<div class="inner-wrap">


    <nav class="top-bar docs-bar hide-for-small" data-topbar>

        <div id="header">
            <h1><a href="index.html">烂笔头</a></h1>
        </div>

    </nav>


    <div class="row">
        <div class="sidebar">
            <ul id="side-nav" class="side-nav">

                
                <li class="side-title"><span>Android</span></li>
                
                <li><a title="Android登录页面，未勾选用户协议、隐私政策出现抖动效果" href="16280609822586.html">Android登录页面，未勾选用户协议、隐私政策出现抖动效果</a></li>
                
                <li><a title="DialogFragment内存泄露问题能不能一次性改好" href="16251021954820.html">DialogFragment内存泄露问题能不能一次性改好</a></li>
                
                <li><a title="Android静默安装实现方案，仿360手机助手秒装和智能安装功能" href="16251021954779.html">Android静默安装实现方案，仿360手机助手秒装和智能安装功能</a></li>
                
                <li><a title="Android 添加水印功能" href="16251021954737.html">Android 添加水印功能</a></li>
                
                <li><a title="Android 监听手电筒状态" href="16251021954689.html">Android 监听手电筒状态</a></li>
                 
                <li class="side-title"><span>Github</span></li>
                
                <li><a title="使用Github+jsdelivr构建你的免费图床" href="16251022060206.html">使用Github+jsdelivr构建你的免费图床</a></li>
                 
                <li class="side-title"><span>Glide</span></li>
                
                <li><a title="Glide源码修改-自定义磁盘缓存实现永久存储" href="16251022251608.html">Glide源码修改-自定义磁盘缓存实现永久存储</a></li>
                
                <li><a title="Android—Glide使用教程（一）" href="16251022251568.html">Android—Glide使用教程（一）</a></li>
                
                <li><a title="Android—Glide使用教程（二）" href="16251022251484.html">Android—Glide使用教程（二）</a></li>
                
                <li><a title="Android—Glide使用教程（三）" href="16251022251527.html">Android—Glide使用教程（三）</a></li>
                 
                <li class="side-title"><span>Gradle</span></li>
                
                <li><a title="Gradle 自定义Plugin插件之上传APK到蒲公英" href="16280610391708.html">Gradle 自定义Plugin插件之上传APK到蒲公英</a></li>
                
                <li><a title="自定义Gradle Plugin，优雅的解决第三方Jar包中的bug" href="16280610391664.html">自定义Gradle Plugin，优雅的解决第三方Jar包中的bug</a></li>
                
                <li><a title="如何使用Android Studio开发Gradle插件" href="16280610391616.html">如何使用Android Studio开发Gradle插件</a></li>
                
                <li><a title="sourceSets使用" href="16251022385733.html">sourceSets使用</a></li>
                
                <li><a title="脑洞大开，Gradle项目管理依赖的船新版本" href="16251022385689.html">脑洞大开，Gradle项目管理依赖的船新版本</a></li>
                 
                <li class="side-title"><span>Rxjava</span></li>
                
                <li><a title="RxJava2 只看这一篇文章就够了" href="16251022491138.html">RxJava2 只看这一篇文章就够了</a></li>
                 
                <li class="side-title"><span>GreenDAO</span></li>
                
                <li><a title="GreenDao 3.3.0 基本使用与入门 （一）" href="16280610693006.html">GreenDao 3.3.0 基本使用与入门 （一）</a></li>
                
                <li><a title="GreenDao 3.3.0 多表关联使用（二）" href="16280610765764.html">GreenDao 3.3.0 多表关联使用（二）</a></li>
                
                <li><a title="GreenDao 3.3.0 增删改查的使用（三）" href="16280610843145.html">GreenDao 3.3.0 增删改查的使用（三）</a></li>
                 
                <li class="side-title"><span>组件化</span></li>
                
                <li><a title="组件化架构之解决Common组件中心化问题(api化方案)" href="16280609309201.html">组件化架构之解决Common组件中心化问题(api化方案)</a></li>
                 
            </ul>
        </div>
        <div class="columns"> <div id="main-content" class="markdown-body">
    <h1>Glide源码修改-自定义磁盘缓存实现永久存储</h1>

    <ul>
<li>
<a href="#toc_0">Glide图片磁盘缓存</a>
</li>
<li>
<a href="#toc_1">Glide磁盘缓存过程源码分析</a>
</li>
<li>
<a href="#toc_2">DiskLruCache</a>
</li>
<li>
<a href="#toc_3">自定义DiskLruCache支持永久存储</a>
</li>
<li>
<a href="#toc_4">项目地址</a>
</li>
</ul>


<h3 id="toc_0">Glide图片磁盘缓存</h3>

<p>在<a href="https://juejin.im/post/6844904200288092167">《Glide实现WebView离线图片的酷炫展示效果》</a>一文中，在webview中的图片我们通过Glide缓存起来，并且将html的内容保存到文件，最终可以在离线下实现文章阅读。其中的图片资源通过glide缓存到cache目录下，我们知道，Glide在加载网络图片时可以将图片缓存到内存与磁盘中。当我们下次使用时，就可以从缓存中获取显示图片。其中的磁盘缓存使用的是<a href="https://github.com/bumptech/glide/blob/master/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/DiskLruCache.java">DiskLruCache</a>算法。  但是缓存文件总大小是有限制的，当超过250M(默认)时，会根据LRU算法删除一些久未使用的图片资源。但是这样会导致离线情况下无法加载一些WebView中的图片（如果）。因此我们希望的是将如果html页面被离线保存下来，那么其中的图片也把它放到一个永久保存的目录下，这些图片资源不会记录到LRU中。</p>

<h3 id="toc_1">Glide磁盘缓存过程源码分析</h3>

<p> 为了能够实现上面的图片永久存储效果，就需要自定义磁盘缓存策略。在这之前，我们需要大致了解下Glide的源码，它是如何将图片缓存到磁盘，又如何使用磁盘中的图片资源的。</p>

<pre><code class="language-kotlin">Glide.with(this).load(url).into(image)
</code></pre>

<p>通过AS调试<code>into</code>方法,发现最终会调用<code>RequestManager</code>的<code>track</code>方法，<code>request</code>实际类型为<code>SingleRequest</code>： <br/>
<img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/0505fc294cf342fb85ed97568a7b62b8_tplv-k3u1fbpfcp-zoom-1.jpg" alt=""/></p>

<p>进入<code>track</code>方法，发现执行的是<code>SingleRequest</code>的<code>begin</code>方法 </p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/d53a5f03355e4a75b553540b68587705_tplv-k3u1fbpfcp-zoom-1.jpg" alt=""/></p>

<p>跟踪调试<code>SingleRequest</code>的<code>begin</code>方法, 执行了<code>DrawableImageViewTarget</code>的<code>getSize</code>方法，并且把自己作为回调参数传入，类型为<code>SizeReadyCallback</code>,猜测估计最终调用<code>onSizeReady</code>方法。</p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/5ad9c3c973364d8cb570167750d0a745_tplv-k3u1fbpfcp-zoom-1.jpg" alt=""/></p>

<p>通过AS快捷键搜索(mac使用command+o)<code>DrawableImageViewTarget</code>类，然后搜索<code>getSize</code>方法(command+F12,输入getSize)，找到对应的实现类<code>ViewTarget</code>。 </p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/d4cb5c09648e4c61bb7fa777e9946a13_tplv-k3u1fbpfcp-zoom-1.jpg" alt=""/></p>

<p>继续调试<code>ViewTarget</code>方法，可以发现是通过<code>ViewTreeObserver</code>获取<code>ImageView</code>获取大小，然后最终回调<code>SingleRequest</code>的<code>onSizeReady</code>方法。 </p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/a53c9bae1e7c42bd9fd8df06f4990606_tplv-k3u1fbpfcp-zoom-1.jpg" alt=""/></p>

<p>回到<code>SingleRequest</code>的<code>onSizeReady</code>方法。<code>status</code>置为<code>RUNNING</code>状态。然后执行<code>Engine</code>中的<code>load方法</code>，继续跟进，发现执行了<code>DecodeJob</code>的<code>runWrapped</code>方法。 <br/>
<img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/5d7bd6b8f06943fdac33d46b37ec3833_tplv-k3u1fbpfcp-zoom-1.jpg" alt=""/></p>

<p>在<code>runGenerators</code>方法中，循环执行了<code>currentGenerator.startNext()</code>方法。<code>DataFetcherGenerator</code>接口的实现类有三个</p>

<ul>
<li>ResourceCacheGenerator</li>
<li>DataCacheGenerator</li>
<li>SourceGenerator</li>
</ul>

<p>而在<code>SourceGenerator</code>的<code>startNext</code>会执行<code>cacheToData</code>缓存磁盘操作,通过<code>DiskLruCacheWrapper</code>的<code>put</code>方法将图片资源缓存到磁盘。 </p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/f6cbb20d107447a98fcf90d309112581_tplv-k3u1fbpfcp-zoom-1.jpg" alt=""/></p>

<p>最终的磁盘缓存算法是通过<code>DiskLruCache</code>类来实现。</p>

<h3 id="toc_2">DiskLruCache</h3>

<p>Glide通过<code>DiskLruCache</code>将图片的原始资源，以及一些指定执行尺寸的资源缓存至磁盘。主要包含一个名为<code>journal</code>的索引文件，以及多个经过hash命名后的图片资源文件。 一个<code>journal</code>文件可能是这样的：</p>

<pre><code class="language-text">libcore.io.DiskLruCache
1
100
2

CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
DIRTY 335c4c6028171cfddfbaae1a9c313c52
CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
REMOVE 335c4c6028171cfddfbaae1a9c313c52
DIRTY 1ab96a171faeeee38496d8b330771a7a
CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
READ 335c4c6028171cfddfbaae1a9c313c52
READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
复制代码
</code></pre>

<p>前4行分别表示文件头信息，<code>disk cache</code>版本，应用版本()，每个缓存项的数量(<code>valueCount</code>)。 第6行开始表示了不同状态的缓存记录，每条记录相关信息通过空格隔开：</p>

<pre><code class="language-text">状态+key+指定状态的相关属性
复制代码
</code></pre>

<ul>
<li><code>DIRTY</code>表示数据正在创建或者更新操作，每个<code>DIRTY</code>脏操作之后都应该有一个<code>CLEAN</code>或者<code>REMOVE</code>操作，没有匹配的<code>CLEAN</code>或<code>REMOVE</code>的脏行表示可能需要删除临时文件。</li>
<li><code>CLEAN</code>表示已成功发布并可能被读取的缓存项，后面表示的是每个值的长度，如果<code>valueCount</code>为2，有两个文件<code>key.0</code>和<code>key.1</code>。后面两个数值表示文件长度。</li>
<li><code>READ</code>表示图片的读取记录，它会进入LRU。</li>
<li><code>REMOVE</code>表示缓存资源的删除操作。</li>
</ul>

<p>默认的<code>DiskLruCache</code>缓存的最大值为<code>250M</code>，当图片文件总长度操作这一数值是，就会进行<code>REMOVE</code>操作。</p>

<pre><code class="language-java">//DiskLruCache.java
private void trimToSize() throws IOException {
    while (size &gt; maxSize) {
      Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next();
      remove(toEvict.getKey());
    }
}
</code></pre>

<p>如果我们离线缓存的图片需要永久使用，那就不能把那些离线图片计入LRU中，不然，当有一天，缓存文件超出250M，一些离线图片就会被删除。因此我们需要定义一个新的<code>PERMANENT</code>（永久）状态，不会进入LRU，并且，我们将这些图片放入另外的文件夹下面。</p>

<h3 id="toc_3">自定义DiskLruCache支持永久存储</h3>

<p>首先我们需要使得Glide支持自定义<code>DiskCache</code>，使用<code>@GlideModule</code>定义一个<code>AppGlideModule</code>，然后在<code>applyOptions</code>方法中实现缓存自定义。</p>

<pre><code class="language-java">@GlideModule
public class MyAppGlideModule extends AppGlideModule {
    
    @Override
    public void applyOptions(@NonNull Context context,
                             @NonNull GlideBuilder builder) {
        super.applyOptions(context, builder);
        builder.setDiskCache(new WanDiskCacheFactory(new WanDiskCacheFactory.CacheDirectoryGetter() {
            @NotNull
            @Override
            public File getCacheDirectory() {
                return new File(context.getCacheDir(), &quot;wandroid_images&quot;);
            }

            @NotNull
            @Override
            public File getPermanentDirectory() {
                return new File(context.getFilesDir(), &quot;permanent_images&quot;);
            }
        }));
    }
}
复制代码
</code></pre>

<p>修改<code>DiskCacheFactory</code>源码，改为<code>WanDiskCacheFactory</code>,新增<code>permanentDirectory</code>目录</p>

<pre><code class="language-kotlin">class WanDiskCacheFactory(var cacheDirectoryGetter: CacheDirectoryGetter) :
    DiskCache.Factory {

    interface CacheDirectoryGetter {
        val cacheDirectory: File
        val permanentDirectory: File
    }

    override fun build(): DiskCache? {
        val cacheDir: File =
            cacheDirectoryGetter.cacheDirectory
        val permanentDirectory = cacheDirectoryGetter.permanentDirectory
        cacheDir.mkdirs()
        permanentDirectory.mkdirs()

        return if ((!cacheDir.exists()
                    || !cacheDir.isDirectory
                    || !permanentDirectory.exists()
                    || !permanentDirectory.isDirectory)
        ) {
            null
        } else WanDiskLruCacheWrapper.create(
            permanentDirectory,
            cacheDir,
            20 * 1024 * 1024//262144000L(250M) for cache
        )

    }
}
</code></pre>

<p>修改<code>DiskLruCache</code>为<code>WanDiskLruCache</code>，添加<code>PERMANENT</code>字段，使得它支持图片永久存储操作。</p>

<pre><code class="language-java">public final class WanDiskLruCache implements Closeable {
    static final String MAGIC = &quot;libcore.io.WanDiskLruCache&quot;;
    ...
    private static final String CLEAN = &quot;CLEAN&quot;;
    private static final String DIRTY = &quot;DIRTY&quot;;
    private static final String REMOVE = &quot;REMOVE&quot;;
    private static final String READ = &quot;READ&quot;;
    private static final String PERMANENT = &quot;PERMANENT&quot;;//长久文件(不进入LRU)
    private void readJournalLine(String line) throws IOException {
        int firstSpace = line.indexOf(&#39; &#39;);
        if (firstSpace == -1) {
            throw new IOException(&quot;unexpected journal line: &quot; + line);
        }

        int keyBegin = firstSpace + 1;
        int secondSpace = line.indexOf(&#39; &#39;, keyBegin);
        final String key;
        if (secondSpace == -1) {
            key = line.substring(keyBegin);
            if (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) {
                lruEntries.remove(key);
                permanentEntries.remove(key);
                return;
            }
            //永久区
            if (firstSpace == PERMANENT.length() &amp;&amp; line.startsWith(PERMANENT)) {
                lruEntries.remove(key);
                Entry entry = permanentEntries.get(key);
                if (entry == null) {
                    entry = new Entry(key, permanentDirectory);
                    entry.readable = true;
                    permanentEntries.put(key, entry);
                }
                return;
            }
        } else {
            key = line.substring(keyBegin, secondSpace);
        }

        ...
    }
    public synchronized Value get(String key) throws IOException {
        checkNotClosed();
        Entry permanentEntry = readPermanentEntry(key);
        if (permanentEntry != null) {
            StringKt.logV(&quot;read from permanent permanent directory:&quot; + key);
            return new Value(key, permanentEntry.sequenceNumber,
                    permanentEntry.cleanFiles,
                    permanentEntry.lengths);
        }
        ...
    }
    /**
     * 读取永久区的文件
     *
     * @param key
     * @return
     */
    private Entry readPermanentEntry(String key) throws IOException {
        Entry entry = permanentEntries.get(key);
        if (entry == null) {
            entry = new Entry(key, permanentDirectory);
            entry.readable = true;
            for (File file : entry.cleanFiles) {
                // A file must have been deleted manually!
                if (!file.exists()) {
                    return null;
                }
            }
            addOpt(PERMANENT, key);
        }
        return entry;
    }
    /**
     * 将缓存的文件移动到permanent下
     */
    public synchronized boolean cacheToPermanent(String key) throws IOException {
        checkNotClosed();
        Entry entry = lruEntries.get(key);
        if (entry == null || entry.currentEditor != null) {
            StringKt.logV(&quot;cacheToPermanent null:&quot; + key);
            return false;
        }

        for (int i = 0; i &lt; valueCount; i++) {
            File file = entry.getCleanFile(i);
            if (file.exists()) {
                FileUtil.copyFileToDirectory(file, permanentDirectory);
                file.delete();
            }
            size -= entry.lengths[i];
            StringKt.logV(&quot;cacheToPermanent:&quot; + entry.getLengths() + &quot;,key:&quot; + entry.key);
            entry.lengths[i] = 0;
        }
        Entry pEntry = new Entry(key, permanentDirectory);
        pEntry.readable = true;
        permanentEntries.put(key, pEntry);
        lruEntries.remove(key);
        addOpt(PERMANENT, key);

        return true;
    }

    /**
     * 删除永久图片
     *
     * @param key
     * @return
     * @throws IOException
     */
    public synchronized boolean removePermanent(String key) throws IOException {
        checkNotClosed();
        Entry entry = readPermanentEntry(key);
        if (entry == null) return false;
        for (int i = 0; i &lt; valueCount; i++) {
            File file = entry.getCleanFile(i);
            if (file.exists() &amp;&amp; !file.delete()) {
                throw new IOException(&quot;failed to delete &quot; + file);
            }
            permanentEntries.remove(key);
        }
        addOpt(REMOVE, key);
        return true;
    }

    /**
     * 将下载好的tmp文件放入永久区
     */
    public synchronized boolean tempToPermanent(File tmp, String key) throws IOException {
        StringKt.logV(&quot;tempToPermanent:&quot; + key);
        Entry entry = new Entry(key, permanentDirectory);
        for (int i = 0; i &lt; valueCount; i++) {
            File file = entry.getCleanFile(i);
            tmp.renameTo(file);
        }
        permanentEntries.put(key, entry);
        addOpt(PERMANENT, key);
        return true;
    }
}
</code></pre>

<p><a href="https://juejin.im/post/6844904200288092167">在通过Glide实现WebView离线图片展示</a>时，将图片资源永久存储有两种情况，一种是图片已经加载，磁盘中已经有相关资源，我们可以通过<code>cacheToPermanent</code>方法，将图片从缓存目录移动到永久目录。另外一种是图片未加载，这种情况离线缓存的话需要下载图片，然后<code>tempToPermanent</code>直接放入永久区域。 </p>

<p><img src="https://cdn.jsdelivr.net/gh/api888/PublicPic@main//img/0d0cb37fdf89410caacdbd41e1ab27cf_tplv-k3u1fbpfcp-zoom-1.jpg" alt=""/></p>

<h3 id="toc_4">项目地址</h3>

<p><a href="https://github.com/iamyours/Wandroid">github.com/iamyours/Wa…</a></p>


</div>

<br /><br />
<hr />

<div class="content-nav">
    <div class="large-6 columns">
        <div class="text-left" style="padding:15px 0px;">
            
            <a href="16251021954689.html" title="Previous Post: Android 监听手电筒状态">&laquo; Android 监听手电筒状态</a> 
        </div>
    </div>
    <div class="large-6 columns">
        <div class="text-right" style="padding:15px 0px;">
            
            <a href="16251022251568.html" title="Next Post: Android—Glide使用教程（一）">Android—Glide使用教程（一） &raquo;</a> 
        </div>
    </div>
</div>

<div class="content_share">
    <div style="padding:0px 0.93em;" class="share-comments">
        
    </div>
</div>
<script type="text/javascript">
    $(function() {
        var currentURL = '16251022251608.html';
        $('#side-nav a').each(function() {
            if ($(this).attr('href') == currentURL) {
                $(this).parent().addClass('active');
            }
        });
    });
</script>  </div>
</div>


<div class="page-bottom">
    <div class="copyright">
        <a href="mailto:888api@sina.com">郝彬彬</a> &copy; 
    </div>
    <div class="copyright text-right">
        <a href="#main-content">TOP</a>
    </div>
</div>

</div>




  














<style type="text/css">
    figure {
        margin: 0.4em 0;
        padding: 0;
    }
    
    figcaption {
        text-align: center;
    }
    /* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
    /**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */
    
    code[class*="language-"],
    pre[class*="language-"] {
        color: black;
        background: none;
        text-shadow: 0 1px white;
        font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
        text-align: left;
        white-space: pre;
        word-spacing: normal;
        word-break: normal;
        word-wrap: normal;
        line-height: 1.5;
        -moz-tab-size: 4;
        -o-tab-size: 4;
        tab-size: 4;
        -webkit-hyphens: none;
        -moz-hyphens: none;
        -ms-hyphens: none;
        hyphens: none;
    }
    
    pre[class*="language-"]::-moz-selection,
    pre[class*="language-"] ::-moz-selection,
    code[class*="language-"]::-moz-selection,
    code[class*="language-"] ::-moz-selection {
        text-shadow: none;
        background: #b3d4fc;
    }
    
    pre[class*="language-"]::selection,
    pre[class*="language-"] ::selection,
    code[class*="language-"]::selection,
    code[class*="language-"] ::selection {
        text-shadow: none;
        background: #b3d4fc;
    }
    
    @media print {
        code[class*="language-"],
        pre[class*="language-"] {
            text-shadow: none;
        }
    }
    /* Code blocks */
    
    pre[class*="language-"] {
        padding: 1em;
        margin: .5em 0;
        overflow: auto;
    }
    
     :not(pre)>code[class*="language-"],
    pre[class*="language-"] {
        background: #F7F7F7;
    }
    /* Inline code */
    
     :not(pre)>code[class*="language-"] {
        padding: .1em;
        border-radius: .3em;
        white-space: normal;
    }
    
    .token.comment,
    .token.prolog,
    .token.doctype,
    .token.cdata {
        color: slategray;
    }
    
    .token.punctuation {
        color: #999;
    }
    
    .namespace {
        opacity: .7;
    }
    
    .token.property,
    .token.tag,
    .token.boolean,
    .token.number,
    .token.constant,
    .token.symbol,
    .token.deleted {
        color: #905;
    }
    
    .token.selector,
    .token.attr-name,
    .token.string,
    .token.char,
    .token.builtin,
    .token.inserted {
        color: #690;
    }
    
    .token.operator,
    .token.entity,
    .token.url,
    .language-css .token.string,
    .style .token.string {
        color: #9a6e3a;
        background: hsla(0, 0%, 100%, .5);
    }
    
    .token.atrule,
    .token.attr-value,
    .token.keyword {
        color: #07a;
    }
    
    .token.function,
    .token.class-name {
        color: #DD4A68;
    }
    
    .token.regex,
    .token.important,
    .token.variable {
        color: #e90;
    }
    
    .token.important,
    .token.bold {
        font-weight: bold;
    }
    
    .token.italic {
        font-style: italic;
    }
    
    .token.entity {
        cursor: help;
    }
    
    pre[class*="language-"].line-numbers {
        position: relative;
        padding-left: 3.8em;
        counter-reset: linenumber;
    }
    
    pre[class*="language-"].line-numbers>code {
        position: relative;
        white-space: inherit;
    }
    
    .line-numbers .line-numbers-rows {
        position: absolute;
        pointer-events: none;
        top: 0;
        font-size: 100%;
        left: -3.8em;
        width: 3em;
        /* works for line-numbers below 1000 lines */
        letter-spacing: -1px;
        border-right: 1px solid #999;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    .line-numbers-rows>span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }
    
    .line-numbers-rows>span:before {
        content: counter(linenumber);
        color: #999;
        display: block;
        padding-right: 0.8em;
        text-align: right;
    }
</style>

<script src="asset/js/foundation.min.js"></script>
<script src="asset/js/foundation/foundation.offcanvas.js"></script>
<script>
    $(document).foundation();
</script>
<script src="asset/js/watermark.js"></script>

</body>

</html>